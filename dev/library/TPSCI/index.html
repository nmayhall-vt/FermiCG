<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>TPSCI · FermiCG</title><link rel="canonical" href="https://nmayhall-vt.github.io/FermiCG/stable/library/TPSCI/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">FermiCG</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../installation_instructions/">Installation Instructions</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../cmf/">Cluster Mean-Field Calculation (CMF)</a></li><li><a class="tocitem" href="../../fci/">Simple (and slow) FCI Calculation (FCI)</a></li></ul></li><li><span class="tocitem">Functions</span><ul><li><a class="tocitem" href="../CMFs/">CMF</a></li><li class="is-active"><a class="tocitem" href>TPSCI</a><ul class="internal"><li><a class="tocitem" href="#Background"><span>Background</span></a></li><li><a class="tocitem" href="#Performance-considerations"><span>Performance considerations</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Documentation"><span>Documentation</span></a></li></ul></li><li><a class="tocitem" href="../BST/">BST</a></li><li><a class="tocitem" href="../Internals/">Internals</a></li><li><a class="tocitem" href="../ClusteredTerms/">ClusteredTerms</a></li><li><a class="tocitem" href="../States/">States</a></li><li><a class="tocitem" href="../PyscfFunctions/">PyscfFunctions</a></li><li><a class="tocitem" href="../StringCI/">StringCI</a></li><li><a class="tocitem" href="../Utils/">Utils</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Functions</a></li><li class="is-active"><a href>TPSCI</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>TPSCI</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/nmayhall-vt/FermiCG/blob/master/docs/src/library/TPSCI.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="TPSCI"><a class="docs-heading-anchor" href="#TPSCI">TPSCI</a><a id="TPSCI-1"></a><a class="docs-heading-anchor-permalink" href="#TPSCI" title="Permalink"></a></h1><h2 id="Background"><a class="docs-heading-anchor" href="#Background">Background</a><a id="Background-1"></a><a class="docs-heading-anchor-permalink" href="#Background" title="Permalink"></a></h2><p>Tensor Product Selected CI (TPSCI) approximates FCI on large active spaces using a sparse basis of tensor products of many-body cluster states. The main idea is fold much of the electron correlation up into the basis vectors themselves, by diagonalizing local Hamiltonians (Hamiltonians acting on disjoint sets of orbitals, &quot;clusters&quot;),  and using the tensor product space of these cluster states as our basis.  For entangled clusters, the convergence of the global energy with the number of local cluster states is slow, making direct truncation of the cluster basis ineffective.  However, instead of seeking a simple trunctation based on local information,  we seek a sparse representation, such that only a small number of global states are needed to obtain an accurate approximation of the ground state. </p><h3 id="Algorithm"><a class="docs-heading-anchor" href="#Algorithm">Algorithm</a><a id="Algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithm" title="Permalink"></a></h3><p>The algorithm consists of the following steps:</p><ol><li><strong>CMF:</strong> Optimize both orbitals and cluster ground states to obtain the variationally best single tensor product state wavefunction.</li><li><strong>Compute basis:</strong> Compute up to <code>M</code> excited states in each Fock sector desired (defaults to all) for each cluster.   These are excited states of the CMF Hamiltonian, which is an effective 1-cluster Hamiltonian containing the 1RDM contributions from all other clusters.</li><li><strong>Form operators:</strong> Compute matrix representations of all the 1, 2, and 3 creation/annihilation operator strings in the CMF cluster basis. E.g.:<div>\[\Gamma_{p^\dagger q\bar{r}}^{I,J} = \left&lt;I\right| \hat{p}^\dagger \hat{q}\hat{\bar{r}}\left| J\right&gt;\]</div>where <code>I</code> and <code>J</code> are cluster states on the same cluster, with well defined particle number and spin-projection. </li><li><strong>Initialize iterations:</strong> Set iteration counter to zero (<span>$n=0$</span>).  Initialize TPSCI state with CMF wavefunction, in the current <span>$\mathcal{P}$</span>-space basis <span>$\lbrace \left|P_i^0\right&gt;\rbrace$</span>, with the orthogonal complement defining the <span>$\mathcal{Q}$</span>-space, <span>$\lbrace \left|Q_i^0\right&gt;\rbrace$</span>.</li><li><strong>Iterate Selected CI:</strong> <ol><li>Diagonalize <span>$\hat{H}$</span> in the current <span>$\mathcal{P}$</span>-space, <span>$\lbrace \left|P_i^n\right&gt;\rbrace$</span><div>\[\hat{P}^n\hat{H}\left|\psi^{(0)}_n\right&gt; = E_n\left|\psi^{(0)}_n\right&gt;\]</div></li><li>Form PT1 wavefunction by applying the Hamiltonian to the current variational state <div>\[\left|\psi^{(1)}_n\right&gt; = \hat{R}\left|\psi^{(0)}_n\right&gt; = \sum_i c_i^{(1)}\left|Q_i^n\right&gt;\]</div>where, <span>$\hat{R}$</span> is the relevant resolvant. </li><li>Select from  <span>$\left|\psi^{(1)}_n\right&gt;$</span> the coefficients with magnitude larger than <code>thresh_cipsi</code> and add to <span>$\mathcal{P}$</span> space:<div>\[\lbrace\left|Q^n_i\right&gt;\rbrace \xrightarrow{|c_i^{(1)}| &gt; \epsilon}\lbrace\left|P^{n+1}_j\right&gt;\rbrace \]</div></li></ol></li></ol><h3 id="Tips-on-clustering"><a class="docs-heading-anchor" href="#Tips-on-clustering">Tips on clustering</a><a id="Tips-on-clustering-1"></a><a class="docs-heading-anchor-permalink" href="#Tips-on-clustering" title="Permalink"></a></h3><h2 id="Performance-considerations"><a class="docs-heading-anchor" href="#Performance-considerations">Performance considerations</a><a id="Performance-considerations-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-considerations" title="Permalink"></a></h2><ul><li>Robust integral screening</li><li><code>thresh_asci</code> </li><li>HOSVD boot-strapping</li></ul><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#FermiCG.build_brdm-Tuple{ClusteredState,Any,Any}"><code>FermiCG.build_brdm</code></a></li><li><a href="#FermiCG.build_full_H-Tuple{ClusteredState,Any,FermiCG.ClusteredOperator}"><code>FermiCG.build_full_H</code></a></li><li><a href="#FermiCG.build_full_H_parallel-Tuple{ClusteredState,Any,FermiCG.ClusteredOperator}"><code>FermiCG.build_full_H_parallel</code></a></li><li><a href="#FermiCG.compute_diagonal-Union{Tuple{R}, Tuple{N}, Tuple{T}, Tuple{ClusteredState{T,N,R},Any,Any}} where R where N where T"><code>FermiCG.compute_diagonal</code></a></li><li><a href="#FermiCG.compute_expectation_value-Union{Tuple{R}, Tuple{N}, Tuple{T}, Tuple{ClusteredState{T,N,R},Any,FermiCG.ClusteredOperator}} where R where N where T"><code>FermiCG.compute_expectation_value</code></a></li><li><a href="#FermiCG.compute_pt2-Union{Tuple{R}, Tuple{N}, Tuple{T}, Tuple{ClusteredState{T,N,R},Any,FermiCG.ClusteredOperator}} where R where N where T"><code>FermiCG.compute_pt2</code></a></li><li><a href="#FermiCG.contract_matrix_element-Tuple{FermiCG.ClusteredTerm4B,Array{FermiCG.ClusterOps,1},FockConfig,ClusterConfig,FockConfig,ClusterConfig}"><code>FermiCG.contract_matrix_element</code></a></li><li><a href="#FermiCG.contract_matrix_element-Tuple{FermiCG.ClusteredTerm2B,Array{FermiCG.ClusterOps,1},FockConfig,ClusterConfig,FockConfig,ClusterConfig}"><code>FermiCG.contract_matrix_element</code></a></li><li><a href="#FermiCG.contract_matrix_element-Tuple{FermiCG.ClusteredTerm3B,Array{FermiCG.ClusterOps,1},FockConfig,ClusterConfig,FockConfig,ClusterConfig}"><code>FermiCG.contract_matrix_element</code></a></li><li><a href="#FermiCG.contract_matrix_element-Tuple{FermiCG.ClusteredTerm1B,Array{FermiCG.ClusterOps,1},FockConfig,ClusterConfig,FockConfig,ClusterConfig}"><code>FermiCG.contract_matrix_element</code></a></li><li><a href="#FermiCG.contract_matvec-Union{Tuple{N}, Tuple{R}, Tuple{T}, Tuple{FermiCG.ClusteredTerm3B,Array{FermiCG.ClusterOps,1},FockConfig{N},FockConfig{N},ClusterConfig{N},StaticArrays.MArray{Tuple{R},T,1,R}}} where N where R where T"><code>FermiCG.contract_matvec</code></a></li><li><a href="#FermiCG.contract_matvec-Union{Tuple{N}, Tuple{R}, Tuple{T}, Tuple{FermiCG.ClusteredTerm4B,Array{FermiCG.ClusterOps,1},FockConfig{N},FockConfig{N},ClusterConfig{N},StaticArrays.MArray{Tuple{R},T,1,R}}} where N where R where T"><code>FermiCG.contract_matvec</code></a></li><li><a href="#FermiCG.contract_matvec-Union{Tuple{N}, Tuple{R}, Tuple{T}, Tuple{FermiCG.ClusteredTerm2B,Array{FermiCG.ClusterOps,1},FockConfig{N},FockConfig{N},ClusterConfig{N},StaticArrays.MArray{Tuple{R},T,1,R}}} where N where R where T"><code>FermiCG.contract_matvec</code></a></li><li><a href="#FermiCG.contract_matvec-Union{Tuple{N}, Tuple{R}, Tuple{T}, Tuple{FermiCG.ClusteredTerm1B,Array{FermiCG.ClusterOps,1},FockConfig{N},FockConfig{N},ClusterConfig{N},StaticArrays.MArray{Tuple{R},T,1,R}}} where N where R where T"><code>FermiCG.contract_matvec</code></a></li><li><a href="#FermiCG.contract_matvec_M3-Union{Tuple{N}, Tuple{R}, Tuple{T}, Tuple{FermiCG.ClusteredTerm3B,Array{FermiCG.ClusterOps,1},FockConfig{N},FockConfig{N},ClusterConfig{N},StaticArrays.MArray{Tuple{R},T,1,R}}} where N where R where T"><code>FermiCG.contract_matvec_M3</code></a></li><li><a href="#FermiCG.contract_matvec_M4-Union{Tuple{N}, Tuple{R}, Tuple{T}, Tuple{FermiCG.ClusteredTerm4B,Array{FermiCG.ClusterOps,1},FockConfig{N},FockConfig{N},ClusterConfig{N},StaticArrays.MArray{Tuple{R},T,1,R}}} where N where R where T"><code>FermiCG.contract_matvec_M4</code></a></li><li><a href="#FermiCG.expand_each_fock_space!-Union{Tuple{R}, Tuple{N}, Tuple{T}, Tuple{ClusteredState{T,N,R},Array{ClusterBasis,1}}} where R where N where T"><code>FermiCG.expand_each_fock_space!</code></a></li><li><a href="#FermiCG.expand_to_full_space!-Tuple{FermiCG.AbstractState,Array{ClusterBasis,1},Any,Any}"><code>FermiCG.expand_to_full_space!</code></a></li><li><a href="#FermiCG.hosvd-Union{Tuple{R}, Tuple{N}, Tuple{T}, Tuple{ClusteredState{T,N,R},Any}} where R where N where T"><code>FermiCG.hosvd</code></a></li><li><a href="#FermiCG.open_matvec-Union{Tuple{R}, Tuple{N}, Tuple{T}, Tuple{ClusteredState{T,N,R},Any,Any}} where R where N where T"><code>FermiCG.open_matvec</code></a></li><li><a href="#FermiCG.open_matvec_parallel-Union{Tuple{R}, Tuple{N}, Tuple{T}, Tuple{ClusteredState{T,N,R},Any,Any}} where R where N where T"><code>FermiCG.open_matvec_parallel</code></a></li><li><a href="#FermiCG.open_matvec_parallel2-Union{Tuple{R}, Tuple{N}, Tuple{T}, Tuple{ClusteredState{T,N,R},Any,Any}} where R where N where T"><code>FermiCG.open_matvec_parallel2</code></a></li><li><a href="#FermiCG.open_matvec_thread-Union{Tuple{R}, Tuple{N}, Tuple{T}, Tuple{ClusteredState{T,N,R},Any,Any}} where R where N where T"><code>FermiCG.open_matvec_thread</code></a></li><li><a href="#FermiCG.project_out!-Tuple{ClusteredState,ClusteredState}"><code>FermiCG.project_out!</code></a></li><li><a href="#FermiCG.tpsci_ci-Union{Tuple{R}, Tuple{N}, Tuple{T}, Tuple{ClusteredState{T,N,R},Any,FermiCG.ClusteredOperator}} where R where N where T"><code>FermiCG.tpsci_ci</code></a></li><li><a href="#FermiCG.upper_bound-Tuple{Array{Float64,3},Any,Any,Any}"><code>FermiCG.upper_bound</code></a></li><li><a href="#FermiCG.upper_bound-Tuple{Array{Float64,2},Any,Any}"><code>FermiCG.upper_bound</code></a></li><li><a href="#FermiCG.upper_bound-Tuple{Array{Float64,4},Any,Any,Any,Any}"><code>FermiCG.upper_bound</code></a></li><li><a href="#FermiCG.upper_bound-Tuple{Any,Any}"><code>FermiCG.upper_bound</code></a></li><li><a href="#FermiCG.upper_bound2-Tuple{Array{Float64,4},Any,Any,Any,Any,Any}"><code>FermiCG.upper_bound2</code></a></li><li><a href="#FermiCG.upper_bound2-Tuple{Array{Float64,3},Any,Any,Any,Any}"><code>FermiCG.upper_bound2</code></a></li></ul><h2 id="Documentation"><a class="docs-heading-anchor" href="#Documentation">Documentation</a><a id="Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Documentation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FermiCG.contract_matrix_element-Tuple{FermiCG.ClusteredTerm1B,Array{FermiCG.ClusterOps,1},FockConfig,ClusterConfig,FockConfig,ClusterConfig}" href="#FermiCG.contract_matrix_element-Tuple{FermiCG.ClusteredTerm1B,Array{FermiCG.ClusterOps,1},FockConfig,ClusterConfig,FockConfig,ClusterConfig}"><code>FermiCG.contract_matrix_element</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">contract_matrix_element(   term::ClusteredTerm1B, 
                                cluster_ops::Vector{ClusterOps},
                                fock_bra::FockConfig, bra::ClusterConfig, 
                                fock_ket::FockConfig, ket::ClusterConfig)</code></pre><p>Contraction for local (1body) terms. No contraction is needed, just a lookup from the correct operator</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nmayhall-vt/FermiCG/blob/578e1704b7b52bbcab89b46353521645b5fe46b4/src/tpsci_inner.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FermiCG.contract_matrix_element-Tuple{FermiCG.ClusteredTerm2B,Array{FermiCG.ClusterOps,1},FockConfig,ClusterConfig,FockConfig,ClusterConfig}" href="#FermiCG.contract_matrix_element-Tuple{FermiCG.ClusteredTerm2B,Array{FermiCG.ClusterOps,1},FockConfig,ClusterConfig,FockConfig,ClusterConfig}"><code>FermiCG.contract_matrix_element</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">contract_matrix_element(   term::ClusteredTerm2B, 
                                cluster_ops::Vector{ClusterOps},
                                fock_bra::FockConfig, bra::ClusterConfig, 
                                fock_ket::FockConfig, ket::ClusterConfig)</code></pre><p>Form TPSCI matrix element by contracting operators with integrals for 2body terms. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nmayhall-vt/FermiCG/blob/578e1704b7b52bbcab89b46353521645b5fe46b4/src/tpsci_inner.jl#L34-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FermiCG.contract_matrix_element-Tuple{FermiCG.ClusteredTerm3B,Array{FermiCG.ClusterOps,1},FockConfig,ClusterConfig,FockConfig,ClusterConfig}" href="#FermiCG.contract_matrix_element-Tuple{FermiCG.ClusteredTerm3B,Array{FermiCG.ClusterOps,1},FockConfig,ClusterConfig,FockConfig,ClusterConfig}"><code>FermiCG.contract_matrix_element</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">contract_matrix_element(   term::ClusteredTerm3B, 
                                cluster_ops::Vector{ClusterOps},
                                fock_bra::FockConfig, bra::ClusterConfig, 
                                fock_ket::FockConfig, ket::ClusterConfig)</code></pre><p>Form TPSCI matrix element by contracting operators with integrals for 3body terms. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nmayhall-vt/FermiCG/blob/578e1704b7b52bbcab89b46353521645b5fe46b4/src/tpsci_inner.jl#L122-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FermiCG.contract_matrix_element-Tuple{FermiCG.ClusteredTerm4B,Array{FermiCG.ClusterOps,1},FockConfig,ClusterConfig,FockConfig,ClusterConfig}" href="#FermiCG.contract_matrix_element-Tuple{FermiCG.ClusteredTerm4B,Array{FermiCG.ClusterOps,1},FockConfig,ClusterConfig,FockConfig,ClusterConfig}"><code>FermiCG.contract_matrix_element</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">contract_matrix_element(   term::ClusteredTerm4B, 
                                cluster_ops::Vector{ClusterOps},
                                fock_bra::FockConfig, bra::ClusterConfig, 
                                fock_ket::FockConfig, ket::ClusterConfig)</code></pre><p>Form TPSCI matrix element by contracting operators with integrals for 4body terms. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nmayhall-vt/FermiCG/blob/578e1704b7b52bbcab89b46353521645b5fe46b4/src/tpsci_inner.jl#L181-L188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FermiCG.contract_matvec-Union{Tuple{N}, Tuple{R}, Tuple{T}, Tuple{FermiCG.ClusteredTerm1B,Array{FermiCG.ClusterOps,1},FockConfig{N},FockConfig{N},ClusterConfig{N},StaticArrays.MArray{Tuple{R},T,1,R}}} where N where R where T" href="#FermiCG.contract_matvec-Union{Tuple{N}, Tuple{R}, Tuple{T}, Tuple{FermiCG.ClusteredTerm1B,Array{FermiCG.ClusterOps,1},FockConfig{N},FockConfig{N},ClusterConfig{N},StaticArrays.MArray{Tuple{R},T,1,R}}} where N where R where T"><code>FermiCG.contract_matvec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">contract_matvec(   term::ClusteredTerm1B, 
                                cluster_ops::Vector{ClusterOps},
                                fock_bra::FockConfig{N}, 
                                fock_ket::FockConfig{N}, conf_ket::ClusterConfig{N}, coef_ket::MVector{R,T};
                                thresh=1e-9) where {T,R,N}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nmayhall-vt/FermiCG/blob/578e1704b7b52bbcab89b46353521645b5fe46b4/src/tpsci_inner.jl#L365-L371">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FermiCG.contract_matvec-Union{Tuple{N}, Tuple{R}, Tuple{T}, Tuple{FermiCG.ClusteredTerm2B,Array{FermiCG.ClusterOps,1},FockConfig{N},FockConfig{N},ClusterConfig{N},StaticArrays.MArray{Tuple{R},T,1,R}}} where N where R where T" href="#FermiCG.contract_matvec-Union{Tuple{N}, Tuple{R}, Tuple{T}, Tuple{FermiCG.ClusteredTerm2B,Array{FermiCG.ClusterOps,1},FockConfig{N},FockConfig{N},ClusterConfig{N},StaticArrays.MArray{Tuple{R},T,1,R}}} where N where R where T"><code>FermiCG.contract_matvec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">contract_matvec(   term::ClusteredTerm2B, 
                                cluster_ops::Vector{ClusterOps},
                                fock_bra::FockConfig{N}, 
                                fock_ket::FockConfig{N}, conf_ket::ClusterConfig{N}, coef_ket::MVector{R,T};
                                thresh=1e-9) where {T,R,N}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nmayhall-vt/FermiCG/blob/578e1704b7b52bbcab89b46353521645b5fe46b4/src/tpsci_inner.jl#L401-L407">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FermiCG.contract_matvec-Union{Tuple{N}, Tuple{R}, Tuple{T}, Tuple{FermiCG.ClusteredTerm3B,Array{FermiCG.ClusterOps,1},FockConfig{N},FockConfig{N},ClusterConfig{N},StaticArrays.MArray{Tuple{R},T,1,R}}} where N where R where T" href="#FermiCG.contract_matvec-Union{Tuple{N}, Tuple{R}, Tuple{T}, Tuple{FermiCG.ClusteredTerm3B,Array{FermiCG.ClusterOps,1},FockConfig{N},FockConfig{N},ClusterConfig{N},StaticArrays.MArray{Tuple{R},T,1,R}}} where N where R where T"><code>FermiCG.contract_matvec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">contract_matvec(   term::ClusteredTerm3B, 
                                cluster_ops::Vector{ClusterOps},
                                fock_bra::FockConfig{N}, 
                                fock_ket::FockConfig{N}, conf_ket::ClusterConfig{N}, coef_ket::MVector{R,T};
                                thresh=1e-9, prescreen=true) where {T,R,N}</code></pre><p>This version should only use M^2N^2 storage, and n^5 scaling n={MN}</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nmayhall-vt/FermiCG/blob/578e1704b7b52bbcab89b46353521645b5fe46b4/src/tpsci_inner.jl#L690-L698">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FermiCG.contract_matvec-Union{Tuple{N}, Tuple{R}, Tuple{T}, Tuple{FermiCG.ClusteredTerm4B,Array{FermiCG.ClusterOps,1},FockConfig{N},FockConfig{N},ClusterConfig{N},StaticArrays.MArray{Tuple{R},T,1,R}}} where N where R where T" href="#FermiCG.contract_matvec-Union{Tuple{N}, Tuple{R}, Tuple{T}, Tuple{FermiCG.ClusteredTerm4B,Array{FermiCG.ClusterOps,1},FockConfig{N},FockConfig{N},ClusterConfig{N},StaticArrays.MArray{Tuple{R},T,1,R}}} where N where R where T"><code>FermiCG.contract_matvec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">contract_matvec(   term::ClusteredTerm4B, 
                                cluster_ops::Vector{ClusterOps},
                                fock_bra::FockConfig{N}, 
                                fock_ket::FockConfig{N}, conf_ket::ClusterConfig{N}, coef_ket::MVector{R,T};
                                thresh=1e-9, prescreen=true) where {T,R,N}</code></pre><p>This version should only use M^2N^2 storage, and n^5 scaling n={MN}</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nmayhall-vt/FermiCG/blob/578e1704b7b52bbcab89b46353521645b5fe46b4/src/tpsci_inner.jl#L783-L791">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FermiCG.contract_matvec_M3-Union{Tuple{N}, Tuple{R}, Tuple{T}, Tuple{FermiCG.ClusteredTerm3B,Array{FermiCG.ClusterOps,1},FockConfig{N},FockConfig{N},ClusterConfig{N},StaticArrays.MArray{Tuple{R},T,1,R}}} where N where R where T" href="#FermiCG.contract_matvec_M3-Union{Tuple{N}, Tuple{R}, Tuple{T}, Tuple{FermiCG.ClusteredTerm3B,Array{FermiCG.ClusterOps,1},FockConfig{N},FockConfig{N},ClusterConfig{N},StaticArrays.MArray{Tuple{R},T,1,R}}} where N where R where T"><code>FermiCG.contract_matvec_M3</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">contract_matvec_M3(   term::ClusteredTerm3B, 
                                cluster_ops::Vector{ClusterOps},
                                fock_bra::FockConfig{N}, 
                                fock_ket::FockConfig{N}, conf_ket::ClusterConfig{N}, coef_ket::MVector{R,T};
                                thresh=1e-9) where {T,R,N}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nmayhall-vt/FermiCG/blob/578e1704b7b52bbcab89b46353521645b5fe46b4/src/tpsci_inner.jl#L479-L485">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FermiCG.contract_matvec_M4-Union{Tuple{N}, Tuple{R}, Tuple{T}, Tuple{FermiCG.ClusteredTerm4B,Array{FermiCG.ClusterOps,1},FockConfig{N},FockConfig{N},ClusterConfig{N},StaticArrays.MArray{Tuple{R},T,1,R}}} where N where R where T" href="#FermiCG.contract_matvec_M4-Union{Tuple{N}, Tuple{R}, Tuple{T}, Tuple{FermiCG.ClusteredTerm4B,Array{FermiCG.ClusterOps,1},FockConfig{N},FockConfig{N},ClusterConfig{N},StaticArrays.MArray{Tuple{R},T,1,R}}} where N where R where T"><code>FermiCG.contract_matvec_M4</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">contract_matvec_M4(   term::ClusteredTerm4B, 
                                cluster_ops::Vector{ClusterOps},
                                fock_bra::FockConfig{N}, 
                                fock_ket::FockConfig{N}, conf_ket::ClusterConfig{N}, coef_ket::MVector{R,T};
                                thresh=1e-9) where {T,R,N}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nmayhall-vt/FermiCG/blob/578e1704b7b52bbcab89b46353521645b5fe46b4/src/tpsci_inner.jl#L554-L560">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FermiCG.upper_bound-Tuple{Any,Any}" href="#FermiCG.upper_bound-Tuple{Any,Any}"><code>FermiCG.upper_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">upper_bound(g1, g2; c::Float64=1.0)</code></pre><p>Return upper bound on the size of matrix elements resulting from matrix multiply </p><pre><code class="language-none">V[I,J] =  g1[i,I] * g2[i,J] * c 

max(|V|) &lt;= sum_i max|g1[i,:]| * max|g2[i,:]| * |c|</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nmayhall-vt/FermiCG/blob/578e1704b7b52bbcab89b46353521645b5fe46b4/src/tpsci_inner.jl#L983-L991">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FermiCG.upper_bound-Tuple{Array{Float64,2},Any,Any}" href="#FermiCG.upper_bound-Tuple{Array{Float64,2},Any,Any}"><code>FermiCG.upper_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">upper_bound(v::Array{Float64,2}, g1, g2; c::Float64=1.0)</code></pre><p>Return upper bound on the size of tensor elements resulting from the following contraction</p><pre><code class="language-none">V[I,J] = v[i,j] * g1[i,I] * g2[j,J] 

max(|V|) &lt;= sum_ij |v[ij]| * |g1[i,:]|_8 * |g2[j,:]|_8 * |c|</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nmayhall-vt/FermiCG/blob/578e1704b7b52bbcab89b46353521645b5fe46b4/src/tpsci_inner.jl#L1010-L1018">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FermiCG.upper_bound-Tuple{Array{Float64,3},Any,Any,Any}" href="#FermiCG.upper_bound-Tuple{Array{Float64,3},Any,Any,Any}"><code>FermiCG.upper_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">upper_bound(v::Array{Float64,3}, g1, g2, g3; c::Float64=1.0)</code></pre><p>Return upper bound on the size of tensor elements resulting from the following contraction</p><pre><code class="language-none">V[I,J,K] = v[i,j,k] * g1[i,I] * g2[j,J] * g3[k,K] 

max(|V|) &lt;= sum_ijk |v[ijk]| * |g1[i,:]|_8 * |g2[j,:]|_8 * |g3[k,:]|_8 * |c|</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nmayhall-vt/FermiCG/blob/578e1704b7b52bbcab89b46353521645b5fe46b4/src/tpsci_inner.jl#L1046-L1054">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FermiCG.upper_bound-Tuple{Array{Float64,4},Any,Any,Any,Any}" href="#FermiCG.upper_bound-Tuple{Array{Float64,4},Any,Any,Any,Any}"><code>FermiCG.upper_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">upper_bound(v::Array{Float64,4}, g1, g2, g3, g4; c::Float64=1.0)</code></pre><p>Return upper bound on the size of tensor elements resulting from the following contraction</p><pre><code class="language-none">V[I,J,K,L] = v[i,j,k,l] * g1[i,I] * g2[j,J] * g3[k,K] * g4[l,L]

max(|V|) &lt;= sum_ijkl |v[ijkl]| * |g1[i,:]|_8 * |g2[j,:]|_8 * |g3[k,:]|_8 * |g4[l,:]|_8</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nmayhall-vt/FermiCG/blob/578e1704b7b52bbcab89b46353521645b5fe46b4/src/tpsci_inner.jl#L1089-L1097">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FermiCG.upper_bound2-Tuple{Array{Float64,3},Any,Any,Any,Any}" href="#FermiCG.upper_bound2-Tuple{Array{Float64,3},Any,Any,Any,Any}"><code>FermiCG.upper_bound2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">upper_bound2(v::Array{Float64,3}, g1, g2, g3, thresh; c::Float64=1.0)</code></pre><p>Get upper bound on the possible values </p><pre><code class="language-none">max(H_IJ(K)|_K &lt;= sum_r (sum_pq vpqrs max(g1[p,:]) * max(g2[q,:]) * |c| ) * |g3(r,K)|</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nmayhall-vt/FermiCG/blob/578e1704b7b52bbcab89b46353521645b5fe46b4/src/tpsci_inner.jl#L1140-L1146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FermiCG.upper_bound2-Tuple{Array{Float64,4},Any,Any,Any,Any,Any}" href="#FermiCG.upper_bound2-Tuple{Array{Float64,4},Any,Any,Any,Any,Any}"><code>FermiCG.upper_bound2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">upper_bound2(v::Array{Float64,4}, g1, g2, g3, g4, thresh; c::Float64=1.0)</code></pre><p>Get upper bound on the possible values </p><pre><code class="language-none">max(H_IJK(L)|_L &lt;= sum_s (sum_pqr vpqrs max(g1[p,:]) * max(g2[q,:]) * max(g3[r,:]) * |c| ) * |g4(s,L)|</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nmayhall-vt/FermiCG/blob/578e1704b7b52bbcab89b46353521645b5fe46b4/src/tpsci_inner.jl#L1226-L1232">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FermiCG.build_brdm-Tuple{ClusteredState,Any,Any}" href="#FermiCG.build_brdm-Tuple{ClusteredState,Any,Any}"><code>FermiCG.build_brdm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">build_brdm(ci_vector::ClusteredState, ci, dims)</code></pre><p>Build block reduced density matrix for <code>Cluster</code>,  <code>ci</code></p><ul><li><code>ci_vector::ClusteredState</code> = input state</li><li><code>ci</code> = Cluster type for whihch we want the BRDM</li><li><code>dims</code> = list of dimensions for each fock sector</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nmayhall-vt/FermiCG/blob/578e1704b7b52bbcab89b46353521645b5fe46b4/src/tpsci_outer.jl#L1066-L1073">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FermiCG.build_full_H-Tuple{ClusteredState,Any,FermiCG.ClusteredOperator}" href="#FermiCG.build_full_H-Tuple{ClusteredState,Any,FermiCG.ClusteredOperator}"><code>FermiCG.build_full_H</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">build_full_H(ci_vector::ClusteredState, cluster_ops, clustered_ham::ClusteredOperator)</code></pre><p>Build full TPSCI Hamiltonian matrix in space spanned by <code>ci_vector</code>. This works in serial for the full matrix</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nmayhall-vt/FermiCG/blob/578e1704b7b52bbcab89b46353521645b5fe46b4/src/tpsci_outer.jl#L5-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FermiCG.build_full_H_parallel-Tuple{ClusteredState,Any,FermiCG.ClusteredOperator}" href="#FermiCG.build_full_H_parallel-Tuple{ClusteredState,Any,FermiCG.ClusteredOperator}"><code>FermiCG.build_full_H_parallel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">build_full_H_parallel(ci_vector::ClusteredState, cluster_ops, clustered_ham::ClusteredOperator)</code></pre><p>Build full TPSCI Hamiltonian matrix in space spanned by <code>ci_vector</code>. This works in serial for the full matrix</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nmayhall-vt/FermiCG/blob/578e1704b7b52bbcab89b46353521645b5fe46b4/src/tpsci_outer.jl#L259-L263">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FermiCG.compute_diagonal-Union{Tuple{R}, Tuple{N}, Tuple{T}, Tuple{ClusteredState{T,N,R},Any,Any}} where R where N where T" href="#FermiCG.compute_diagonal-Union{Tuple{R}, Tuple{N}, Tuple{T}, Tuple{ClusteredState{T,N,R},Any,Any}} where R where N where T"><code>FermiCG.compute_diagonal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">compute_diagonal(vector::ClusteredState{T,N,R}, cluster_ops, clustered_ham) where {T,N,R}</code></pre><p>Form the diagonal of the hamiltonan, <code>clustered_ham</code>, in the basis defined by <code>vector</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nmayhall-vt/FermiCG/blob/578e1704b7b52bbcab89b46353521645b5fe46b4/src/tpsci_outer.jl#L834-L838">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FermiCG.compute_expectation_value-Union{Tuple{R}, Tuple{N}, Tuple{T}, Tuple{ClusteredState{T,N,R},Any,FermiCG.ClusteredOperator}} where R where N where T" href="#FermiCG.compute_expectation_value-Union{Tuple{R}, Tuple{N}, Tuple{T}, Tuple{ClusteredState{T,N,R},Any,FermiCG.ClusteredOperator}} where R where N where T"><code>FermiCG.compute_expectation_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">compute_expectation_value(ci_vector::ClusteredState{T,N,R}, cluster_ops, clustered_ham::ClusteredOperator; nbody=4) where {T,N,R}</code></pre><p>Compute expectation value of a <code>ClusteredOperator</code> (<code>clustered_ham</code>) for state <code>ci_vector</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nmayhall-vt/FermiCG/blob/578e1704b7b52bbcab89b46353521645b5fe46b4/src/tpsci_outer.jl#L429-L433">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FermiCG.compute_pt2-Union{Tuple{R}, Tuple{N}, Tuple{T}, Tuple{ClusteredState{T,N,R},Any,FermiCG.ClusteredOperator}} where R where N where T" href="#FermiCG.compute_pt2-Union{Tuple{R}, Tuple{N}, Tuple{T}, Tuple{ClusteredState{T,N,R},Any,FermiCG.ClusteredOperator}} where R where N where T"><code>FermiCG.compute_pt2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">compute_pt2(ci_vector::ClusteredState{T,N,R}, cluster_ops, clustered_ham::ClusteredOperator; 
    nbody=4, 
    H0=&quot;Hcmf&quot;,
    E0=nothing, #pass in &lt;0|H0|0&gt;, or compute it
    thresh_foi=1e-8, 
    verbose=1,
    matvec=3) where {T,N,R}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nmayhall-vt/FermiCG/blob/578e1704b7b52bbcab89b46353521645b5fe46b4/src/tpsci_outer.jl#L349-L357">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FermiCG.expand_each_fock_space!-Union{Tuple{R}, Tuple{N}, Tuple{T}, Tuple{ClusteredState{T,N,R},Array{ClusterBasis,1}}} where R where N where T" href="#FermiCG.expand_each_fock_space!-Union{Tuple{R}, Tuple{N}, Tuple{T}, Tuple{ClusteredState{T,N,R},Array{ClusterBasis,1}}} where R where N where T"><code>FermiCG.expand_each_fock_space!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">expand_each_fock_space!(s::ClusteredState{T,N,R}, bases::Vector{ClusterBasis}) where {T,N,R}</code></pre><p>For each fock space sector defined, add all possible basis states</p><ul><li><code>basis::Vector{ClusterBasis}</code> </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nmayhall-vt/FermiCG/blob/578e1704b7b52bbcab89b46353521645b5fe46b4/src/tpsci_outer.jl#L862-L867">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FermiCG.expand_to_full_space!-Tuple{FermiCG.AbstractState,Array{ClusterBasis,1},Any,Any}" href="#FermiCG.expand_to_full_space!-Tuple{FermiCG.AbstractState,Array{ClusterBasis,1},Any,Any}"><code>FermiCG.expand_to_full_space!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">expand_to_full_space!(s::AbstractState, bases::Vector{ClusterBasis}, na, nb)</code></pre><p>Define all possible fock space sectors and add all possible basis states</p><ul><li><code>basis::Vector{ClusterBasis}</code> </li><li><code>na</code>: Number of alpha electrons total</li><li><code>nb</code>: Number of alpha electrons total</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nmayhall-vt/FermiCG/blob/578e1704b7b52bbcab89b46353521645b5fe46b4/src/tpsci_outer.jl#L894-L901">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FermiCG.hosvd-Union{Tuple{R}, Tuple{N}, Tuple{T}, Tuple{ClusteredState{T,N,R},Any}} where R where N where T" href="#FermiCG.hosvd-Union{Tuple{R}, Tuple{N}, Tuple{T}, Tuple{ClusteredState{T,N,R},Any}} where R where N where T"><code>FermiCG.hosvd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hosvd(ci_vector::ClusteredState{T,N,R}, cluster_ops; hshift=1e-8, truncate=-1) where {T,N,R}</code></pre><p>Peform HOSVD aka Tucker Decomposition of ClusteredState</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nmayhall-vt/FermiCG/blob/578e1704b7b52bbcab89b46353521645b5fe46b4/src/tpsci_outer.jl#L955-L959">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FermiCG.open_matvec-Union{Tuple{R}, Tuple{N}, Tuple{T}, Tuple{ClusteredState{T,N,R},Any,Any}} where R where N where T" href="#FermiCG.open_matvec-Union{Tuple{R}, Tuple{N}, Tuple{T}, Tuple{ClusteredState{T,N,R},Any,Any}} where R where N where T"><code>FermiCG.open_matvec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">open_matvec(ci_vector::ClusteredState{T,N,R}, cluster_ops, clustered_ham; thresh=1e-9, nbody=4) where {T,N,R}</code></pre><p>Compute the action of the Hamiltonian on a tpsci state vector. Open here, means that we access the full FOIS  (restricted only by thresh), instead of the action of H on v within a subspace of configurations.  This is essentially used for computing a PT correction outside of the subspace, or used for searching in TPSCI.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nmayhall-vt/FermiCG/blob/578e1704b7b52bbcab89b46353521645b5fe46b4/src/tpsci_outer.jl#L474-L480">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FermiCG.open_matvec_parallel-Union{Tuple{R}, Tuple{N}, Tuple{T}, Tuple{ClusteredState{T,N,R},Any,Any}} where R where N where T" href="#FermiCG.open_matvec_parallel-Union{Tuple{R}, Tuple{N}, Tuple{T}, Tuple{ClusteredState{T,N,R},Any,Any}} where R where N where T"><code>FermiCG.open_matvec_parallel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">open_matvec_parallel(ci_vector::ClusteredState{T,N,R}, cluster_ops, clustered_ham; thresh=1e-9, nbody=4) where {T,N,R}</code></pre><p>Compute the action of the Hamiltonian on a tpsci state vector. Open here, means that we access the full FOIS  (restricted only by thresh), instead of the action of H on v within a subspace of configurations.  This is essentially used for computing a PT correction outside of the subspace, or used for searching in TPSCI.</p><p>This parallellizes over FockConfigs in the output state, so it&#39;s not the most fine-grained, but it avoids data races in  filling the final vector</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nmayhall-vt/FermiCG/blob/578e1704b7b52bbcab89b46353521645b5fe46b4/src/tpsci_outer.jl#L637-L646">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FermiCG.open_matvec_parallel2-Union{Tuple{R}, Tuple{N}, Tuple{T}, Tuple{ClusteredState{T,N,R},Any,Any}} where R where N where T" href="#FermiCG.open_matvec_parallel2-Union{Tuple{R}, Tuple{N}, Tuple{T}, Tuple{ClusteredState{T,N,R},Any,Any}} where R where N where T"><code>FermiCG.open_matvec_parallel2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">open_matvec_parallel2(ci_vector::ClusteredState{T,N,R}, cluster_ops, clustered_ham; thresh=1e-9, nbody=4) where {T,N,R}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nmayhall-vt/FermiCG/blob/578e1704b7b52bbcab89b46353521645b5fe46b4/src/tpsci_outer.jl#L756-L758">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FermiCG.open_matvec_thread-Union{Tuple{R}, Tuple{N}, Tuple{T}, Tuple{ClusteredState{T,N,R},Any,Any}} where R where N where T" href="#FermiCG.open_matvec_thread-Union{Tuple{R}, Tuple{N}, Tuple{T}, Tuple{ClusteredState{T,N,R},Any,Any}} where R where N where T"><code>FermiCG.open_matvec_thread</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">open_matvec_thread(ci_vector::ClusteredState{T,N,R}, cluster_ops, clustered_ham; thresh=1e-9, nbody=4) where {T,N,R}</code></pre><p>Compute the action of the Hamiltonian on a tpsci state vector. Open here, means that we access the full FOIS  (restricted only by thresh), instead of the action of H on v within a subspace of configurations.  This is essentially used for computing a PT correction outside of the subspace, or used for searching in TPSCI.</p><p>This parallellizes over FockConfigs in the output state, so it&#39;s not the most fine-grained, but it avoids data races in  filling the final vector</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nmayhall-vt/FermiCG/blob/578e1704b7b52bbcab89b46353521645b5fe46b4/src/tpsci_outer.jl#L534-L543">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FermiCG.project_out!-Tuple{ClusteredState,ClusteredState}" href="#FermiCG.project_out!-Tuple{ClusteredState,ClusteredState}"><code>FermiCG.project_out!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">project_out!(v::ClusteredState, w::ClusteredState)</code></pre><p>Project w out of v      |v&#39;&gt; = |v&gt; - |w&gt;&lt;w|v&gt;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nmayhall-vt/FermiCG/blob/578e1704b7b52bbcab89b46353521645b5fe46b4/src/tpsci_outer.jl#L935-L940">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FermiCG.tpsci_ci-Union{Tuple{R}, Tuple{N}, Tuple{T}, Tuple{ClusteredState{T,N,R},Any,FermiCG.ClusteredOperator}} where R where N where T" href="#FermiCG.tpsci_ci-Union{Tuple{R}, Tuple{N}, Tuple{T}, Tuple{ClusteredState{T,N,R},Any,FermiCG.ClusteredOperator}} where R where N where T"><code>FermiCG.tpsci_ci</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">tpsci_ci(ci_vector::ClusteredState{T,N,R}, cluster_ops, clustered_ham::ClusteredOperator;
        thresh_cipsi = 1e-2,
        thresh_foi   = 1e-6,
        thresh_asci  = 1e-2,
        thresh_var   = -1.0,
        max_iter     = 10,
        conv_thresh  = 1e-4,
        nbody        = 4,
        incremental  = true,
        matvec       = 1) where {T,N,R}</code></pre><p><strong>Run TPSCI</strong></p><ul><li><code>thresh_cipsi</code>: threshold for which configurations to include in the variational space. Add if |c^{(1)}| &gt; <code>thresh_cipsi</code></li><li><code>thresh_foi</code>  : threshold for which terms to keep in the H|0&gt; vector used to form the first order wavefunction</li><li><code>thresh_asci</code> : threshold for determining from which variational configurations  <span>$|c^{(0)}_i|$</span> &gt; <code>thresh_asci</code> </li><li><code>thresh_var</code>  : threshold for clipping the result of the variational wavefunction. Not really needed default set to -1 (off)</li><li><code>max_iter</code>    : maximum selected CI iterations</li><li><code>conv_thresh</code> : stop selected CI iterations when energy change is smaller than <code>conv_thresh</code></li><li><code>nbody</code>       : only consider up to <code>nbody</code> terms when searching for new configurations</li><li><code>incremental</code> : for the sigma vector incrementally between iterations</li><li><code>matvec</code>      : which implementation of the matrix vector code</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nmayhall-vt/FermiCG/blob/578e1704b7b52bbcab89b46353521645b5fe46b4/src/tpsci_outer.jl#L54-L76">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../CMFs/">« CMF</a><a class="docs-footer-nextpage" href="../BST/">BST »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 13 June 2021 01:51">Sunday 13 June 2021</span>. Using Julia version 1.5.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
