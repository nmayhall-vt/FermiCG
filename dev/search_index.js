var documenterSearchIndex = {"docs":
[{"location":"library/States/#Wavefunction-types","page":"States","title":"Wavefunction types","text":"","category":"section"},{"location":"library/States/","page":"States","title":"States","text":"Each of the methods implemented in this package use a unique data representation for the wavefunction. These all rely on some kind of hash table lookup, and so the following indexing schemes are defined to make this easier and faster (i.e., implemented using only stack allocated data).","category":"page"},{"location":"library/States/","page":"States","title":"States","text":"List of Indexing types for representing states","category":"page"},{"location":"library/States/","page":"States","title":"States","text":"ClusterConfig\nTuckerConfig\nFockConfig","category":"page"},{"location":"library/States/","page":"States","title":"States","text":"Each of the different wavefunction types map different Index types to data (wavefunction coefficients)","category":"page"},{"location":"library/States/","page":"States","title":"States","text":"TPSCI: ClusteredState: Maps FockConfig → ClusterConfig →  Vector of coefficients (one for each state)\nBST: CompressedTuckerState: Maps FockConfig → TuckerConfig →  Tucker instance representing compressed set of coefficients for that subspace","category":"page"},{"location":"library/States/#Index","page":"States","title":"Index","text":"","category":"section"},{"location":"library/States/","page":"States","title":"States","text":"Pages = [\"States.md\"]","category":"page"},{"location":"library/States/#Types","page":"States","title":"Types","text":"","category":"section"},{"location":"library/States/","page":"States","title":"States","text":"Modules = [FermiCG]\nPages   = [\"States.jl\", \n\t\"FockSparse_ElementSparse.jl\",\n\t\"FockSparse_BlockSparse.jl\",\t\n\t\"FockSparse_BlockSparseTucker.jl\", \n\t\"Indexing.jl\"]\nOrder   = [:type]\nDepth\t= 2","category":"page"},{"location":"library/States/#Methods","page":"States","title":"Methods","text":"","category":"section"},{"location":"library/States/","page":"States","title":"States","text":"Modules = [FermiCG]\nPages   = [\"States.jl\", \n\t\"FockSparse_ElementSparse.jl\",\n\t\"FockSparse_BlockSparse.jl\",\t\n\t\"FockSparse_BlockSparseTucker.jl\", \n\t\"Indexing.jl\"]\nOrder   = [:function]\nDepth\t= 2","category":"page"},{"location":"library/States/#Base.:+-Union{Tuple{N}, Tuple{FockConfig{N},FermiCG.TransferConfig{N}}} where N","page":"States","title":"Base.:+","text":"Base.:+(a::FockConfig, b::TransferConfig)\n\nAdd a FockConfig to a TransferConfig to get a new FockConfig\n\n\n\n\n\n","category":"method"},{"location":"library/States/#Base.:--Union{Tuple{N}, Tuple{FockConfig{N},FermiCG.TransferConfig{N}}} where N","page":"States","title":"Base.:-","text":"Base.:-(a::FockConfig, b::TransferConfig)\n\n\n\n\n\n","category":"method"},{"location":"library/States/#Base.:--Union{Tuple{N}, Tuple{FockConfig{N},FockConfig{N}}} where N","page":"States","title":"Base.:-","text":"Base.:-(a::FockConfig, b::FockConfig)\n\nSubtract two FockConfig's, returning a TransferConfig\n\n\n\n\n\n","category":"method"},{"location":"library/ClusteredStates/","page":"ClusteredStates","title":"ClusteredStates","text":"Pages = [\"ClusteredStates.md\"]","category":"page"},{"location":"library/ClusteredStates/#ClusteredStates","page":"ClusteredStates","title":"ClusteredStates","text":"","category":"section"},{"location":"library/ClusteredStates/","page":"ClusteredStates","title":"ClusteredStates","text":"Modules = [FermiCG]\nPages   = [\"ClusteredStates.jl\"]\nOrder   = [:type, :function]\nDepth\t= 2","category":"page"},{"location":"installation_instructions/#FermiCG","page":"Installation Instructions","title":"FermiCG","text":"","category":"section"},{"location":"installation_instructions/","page":"Installation Instructions","title":"Installation Instructions","text":"A Julia package for course-grained electronic structure calculations","category":"page"},{"location":"installation_instructions/#Installation","page":"Installation Instructions","title":"Installation","text":"","category":"section"},{"location":"installation_instructions/","page":"Installation Instructions","title":"Installation Instructions","text":"Download","category":"page"},{"location":"installation_instructions/","page":"Installation Instructions","title":"Installation Instructions","text":"git clone https://github.com/nmayhall-vt/FermiCG.git\ncd FermiCG/","category":"page"},{"location":"installation_instructions/","page":"Installation Instructions","title":"Installation Instructions","text":"Create python virtual environment which will hold the PYSCF executable","category":"page"},{"location":"installation_instructions/","page":"Installation Instructions","title":"Installation Instructions","text":"cd src/python\nvirtualenv -p python3 venv\nsource venv/bin/activate\npip install -r requirements.txt\ncd ../../\njulia --project=./\njulia> using Pkg; Pkg.build(\"PyCall\")","category":"page"},{"location":"cmf/#Cluster-Mean-Field-Calculation-(CMF)","page":"Cluster Mean-Field Calculation (CMF)","title":"Cluster Mean-Field Calculation (CMF)","text":"","category":"section"},{"location":"cmf/","page":"Cluster Mean-Field Calculation (CMF)","title":"Cluster Mean-Field Calculation (CMF)","text":"In this example, we cluster a sequence of H<sub>2</sub> molecules and solve them self-consistently","category":"page"},{"location":"cmf/#First-create-a-molecule","page":"Cluster Mean-Field Calculation (CMF)","title":"First create a molecule","text":"","category":"section"},{"location":"cmf/","page":"Cluster Mean-Field Calculation (CMF)","title":"Cluster Mean-Field Calculation (CMF)","text":"using FermiCG\n\natoms = []\npush!(atoms,Atom(1,\"H\",[0,0,0]))\npush!(atoms,Atom(2,\"H\",[0,0,1]))\npush!(atoms,Atom(3,\"H\",[0,0,2]))\npush!(atoms,Atom(4,\"H\",[0,0,3]))\npush!(atoms,Atom(5,\"H\",[0,0,4]))\npush!(atoms,Atom(6,\"H\",[0,0,5]))\nbasis = \"sto-3g\"","category":"page"},{"location":"cmf/","page":"Cluster Mean-Field Calculation (CMF)","title":"Cluster Mean-Field Calculation (CMF)","text":"Now create a PySCF object for creating integrals, and run FCI with 3 alpha and 3 beta electrons","category":"page"},{"location":"cmf/","page":"Cluster Mean-Field Calculation (CMF)","title":"Cluster Mean-Field Calculation (CMF)","text":"mol  = Molecule(0,1,atoms)\nmf   = FermiCG.pyscf_do_scf(mol,basis)\nints = FermiCG.pyscf_build_ints(mf.mol,mf.mo_coeff);\n\nna = 3\nnb = 3\ne_fci, d1_fci, d2_fci = FermiCG.pyscf_fci(ints,na,nb)\nC = mf.mo_coeff\nrdm_mf = C[:,1:2] * C[:,1:2]'","category":"page"},{"location":"cmf/","page":"Cluster Mean-Field Calculation (CMF)","title":"Cluster Mean-Field Calculation (CMF)","text":"Localize the orbitals and print to molden file for viewing","category":"page"},{"location":"cmf/","page":"Cluster Mean-Field Calculation (CMF)","title":"Cluster Mean-Field Calculation (CMF)","text":"Cl = FermiCG.localize(mf.mo_coeff,\"lowdin\",mf)\nFermiCG.pyscf_write_molden(mol,basis,Cl,filename=\"lowdin.molden\")\nS = FermiCG.get_ovlp(mf)\nU =  C' * S * Cl","category":"page"},{"location":"cmf/","page":"Cluster Mean-Field Calculation (CMF)","title":"Cluster Mean-Field Calculation (CMF)","text":"Rotate the integrals to this new localized basis","category":"page"},{"location":"cmf/","page":"Cluster Mean-Field Calculation (CMF)","title":"Cluster Mean-Field Calculation (CMF)","text":"ints = FermiCG.orbital_rotation(ints,U)","category":"page"},{"location":"cmf/","page":"Cluster Mean-Field Calculation (CMF)","title":"Cluster Mean-Field Calculation (CMF)","text":"Now we need to specify a clustering","category":"page"},{"location":"cmf/","page":"Cluster Mean-Field Calculation (CMF)","title":"Cluster Mean-Field Calculation (CMF)","text":"clusters    = [(1:2),(3:4),(5:6)]\ninit_fspace = [(1,1),(1,1),(1,1)]\n\nclusters = [Cluster(i,collect(clusters[i])) for i = 1:length(clusters)]\ndisplay(clusters)\n\nrdm1 = zeros(size(ints.h1))\nrdm1a = rdm_mf*.5\nrdm1b = rdm_mf*.5\n","category":"page"},{"location":"cmf/","page":"Cluster Mean-Field Calculation (CMF)","title":"Cluster Mean-Field Calculation (CMF)","text":"Now run the orbital optimization and dump the resultinging orbitals ","category":"page"},{"location":"cmf/","page":"Cluster Mean-Field Calculation (CMF)","title":"Cluster Mean-Field Calculation (CMF)","text":"U = FermiCG.cmf_oo(ints, clusters, init_fspace, rdm1, verbose=0, gconv=1e-6)\n\nC_cmf = Cl*U\n\nFermiCG.pyscf_write_molden(mol,basis,C_cmf,filename=\"cmf.molden\")","category":"page"},{"location":"library/BST/#BST","page":"BST","title":"BST","text":"","category":"section"},{"location":"library/BST/","page":"BST","title":"BST","text":"The Block-Sparse Tucker (BST) method, approximates FCI as a linear combination of individually compressed (via HOSVD) blocks of the Hilbert space.","category":"page"},{"location":"library/BST/#Background","page":"BST","title":"Background","text":"","category":"section"},{"location":"library/BST/","page":"BST","title":"BST","text":"Similar to TPSCI, the approach here starts with a CMF wavefunction, and systematically reintroduces the discarded tensor product states to variationally approach FCI. Unlike with TPSCI, however, we don't assume that the final wavefunction is written as  a purely sparse form (where only a few TPS's are needed), but rather we assume that collections of TPS's where certain numbers of clusters are \"excited\" can be efficiently compressed via HOSVD (although the basic idea would extend to other tensor decompositions, like CP or MPS). ","category":"page"},{"location":"library/BST/#Performance-considerations","page":"BST","title":"Performance considerations","text":"","category":"section"},{"location":"library/BST/#Index","page":"BST","title":"Index","text":"","category":"section"},{"location":"library/BST/","page":"BST","title":"BST","text":"Pages   = [\"BST.md\"]","category":"page"},{"location":"library/BST/#Documentation","page":"BST","title":"Documentation","text":"","category":"section"},{"location":"library/BST/","page":"BST","title":"BST","text":"Modules = [FermiCG]\nPages   = [\"tucker_inner.jl\",\"tucker_outer.jl\",\"bst.jl\"]\nOrder   = [:type, :function]\nDepth\t= 2","category":"page"},{"location":"library/BST/#FermiCG.build_sigma!-Union{Tuple{R}, Tuple{N}, Tuple{T}, Tuple{FermiCG.BSTstate{T,N,R},FermiCG.BSTstate{T,N,R},Any,Any}} where R where N where T","page":"BST","title":"FermiCG.build_sigma!","text":"build_sigma_parallel!(sigma_vector::BSTstate, ci_vector::BSTstate, cluster_ops, clustered_ham)\n\n\n\n\n\n","category":"method"},{"location":"library/BST/#FermiCG.build_sigma_serial!-Union{Tuple{R}, Tuple{N}, Tuple{T}, Tuple{FermiCG.BSTstate{T,N,R},FermiCG.BSTstate{T,N,R},Any,Any}} where R where N where T","page":"BST","title":"FermiCG.build_sigma_serial!","text":"build_sigma!(sigma_vector::BSTstate, ci_vector::BSTstate, cluster_ops, clustered_ham)\n\n\n\n\n\n","category":"method"},{"location":"library/BST/#FermiCG.cache_hamiltonian_old-Tuple{FermiCG.BSTstate,FermiCG.BSTstate,Any,Any}","page":"BST","title":"FermiCG.cache_hamiltonian_old","text":"build_sigma!(sigma_vector::BSTstate, ci_vector::BSTstate, cluster_ops, clustered_ham)\n\n\n\n\n\n","category":"method"},{"location":"library/BST/#FermiCG.build_compressed_1st_order_state-Union{Tuple{R}, Tuple{N}, Tuple{T}, Tuple{FermiCG.BSTstate{T,N,R},Any,Any}} where R where N where T","page":"BST","title":"FermiCG.build_compressed_1st_order_state","text":"build_compressed_1st_order_state(ket_cts::BSTstate{T,N}, cluster_ops, clustered_ham; \n    thresh=1e-7, \n    max_number=nothing, \n    nbody=4) where {T,N}\n\nApply the Hamiltonian to v expanding into the uncompressed space. This is done only partially, where each term is recompressed after being computed. Lots of overhead probably from compression, but never completely uncompresses.\n\n#Arguments\n\ncts::BSTstate: input state\ncluster_ops:\nclustered_ham: Hamiltonian\nthresh: Threshold for each HOSVD \nmax_number: max number of tucker factors kept in each HOSVD\nnbody: allows one to limit (max 4body) terms in the Hamiltonian considered\n\n#Returns\n\nv1::BSTstate\n\n\n\n\n\n","category":"method"},{"location":"library/BST/#FermiCG.ci_solve-Union{Tuple{R}, Tuple{N}, Tuple{T}, Tuple{FermiCG.BSTstate{T,N,R},Any,Any}} where R where N where T","page":"BST","title":"FermiCG.ci_solve","text":"function ci_solve(ci_vector_in::BSTstate{T,N,R}, cluster_ops, clustered_ham; \n                     conv_thresh = 1e-5,\n                     max_ss_vecs = 12,\n                     max_iter    = 40,\n                     shift       = nothing,\n                     precond     = false,\n                     verbose     = 0,\n                     solver      = \"davidson\") where {T,N,R}\n\nSolve for ground state in the space spanned by ci_vector's compression vectors\n\nArguments\n\nconv_thresh: residual convergence threshold\nmax_ss_vecs: max number of subspace vectors\nmax_iter: Max iterations in solver\nshift:  Use a shift? this is for CEPA type \nprecond: use preconditioner? Only applied to Davidson and not yet working,\nverbose: print level\nsolver: Which solver to use. Options = [\"davidson\", \"krylovkit\"]\n\n\n\n\n\n","category":"method"},{"location":"library/BST/#FermiCG.define_foi_space-Union{Tuple{T}, Tuple{T,Any}} where T<:Union{FermiCG.BSTstate, FermiCG.BSstate}","page":"BST","title":"FermiCG.define_foi_space","text":"define_foi_space(v::BSTstate, clustered_ham; nbody=2)\n\nCompute the first-order interacting space as defined by clustered_ham\n\n#Arguments\n\nv::BSTstate: input state\nclustered_ham: Hamiltonian\nnbody: allows one to limit (max 4body) terms in the Hamiltonian considered\n\n#Returns\n\nfoi::OrderedDict{FockConfig,Vector{TuckerConfig}}\n\n\n\n\n\n","category":"method"},{"location":"library/BST/#FermiCG.get_map-Union{Tuple{R}, Tuple{N}, Tuple{T}, Tuple{FermiCG.BSTstate{T,N,R},Any,Any}} where R where N where T","page":"BST","title":"FermiCG.get_map","text":"get_map(ci_vector::BSTstate, cluster_ops, clustered_ham)\n\nGet LinearMap with takes a vector and returns action of H on that vector\n\n\n\n\n\n","category":"method"},{"location":"library/BST/#FermiCG.project_out!-Union{Tuple{Rw}, Tuple{Rv}, Tuple{N}, Tuple{T}, Tuple{FermiCG.BSTstate{T,N,Rv},FermiCG.BSTstate{T,N,Rw}}} where Rw where Rv where N where T","page":"BST","title":"FermiCG.project_out!","text":"project_out!(v::BSTstate, w::BSTstate; thresh=1e-16)\n\nProject w out of v  |v'> = |v> - |w><w|v>\n\n\n\n\n\n","category":"method"},{"location":"library/BST/#FermiCG.tucker_cepa_solve-Union{Tuple{R}, Tuple{N}, Tuple{T}, Tuple{FermiCG.BSTstate{T,N,R},FermiCG.BSTstate,Any,Any}, Tuple{FermiCG.BSTstate{T,N,R},FermiCG.BSTstate,Any,Any,Any}, Tuple{FermiCG.BSTstate{T,N,R},FermiCG.BSTstate,Any,Any,Any,Any}} where R where N where T","page":"BST","title":"FermiCG.tucker_cepa_solve","text":"tucker_cepa_solve!(ref_vector::BSTstate, cepa_vector::BSTstate, cluster_ops, clustered_ham; tol=1e-5, cache=true)\n\nArguments\n\nref_vector: Input reference state. \ncepa_vector: BSTstate which defines the configurational space defining {X}. This \n\nshould be the first-order interacting space (or some compressed version of it).\n\ncluster_ops\nclustered_ham\ntol: haven't yet set this up (NYI)\ncache: Should we cache the compressed H operators? Speeds up drastically, but uses lots of memory\n\nCompute compressed CEPA. Since there can be non-zero overlap with a multireference state, we need to generalize.\n\nHC = SCe\n\n|Haa + Hax| |1 | = |I   + Sax| |1 | E\n|Hxa + Hxx| |Cx|   |Sxa + I  | |Cx|\n\nHaa + Hax*Cx = (1 + Sax*Cx)E\nHxa + HxxCx = SxaE + CxE\n\nThe idea for CEPA is to approximate E in the amplitude equation. CEPA(0): E = Eref\n\n(Hxx-Eref)*Cx = Sxa*Eref - Hxa\n\nAx=b\n\nAfter solving, the Energy can be obtained as:\n\nE = (Eref + Hax*Cx) / (1 + Sax*Cx)\n\n\n\n\n\n","category":"method"},{"location":"library/BST/#FermiCG.tucker_cepa_solve2-Tuple{FermiCG.BSTstate,FermiCG.BSTstate,Any,Any}","page":"BST","title":"FermiCG.tucker_cepa_solve2","text":"tucker_cepa_solve!(ref_vector::BSTstate, cepa_vector::BSTstate, cluster_ops, clustered_ham; tol=1e-5, cache=true)\n\nArguments\n\nref_vector: Input reference state. \ncepa_vector: BSTstate which defines the configurational space defining {X}. This \n\nshould be the first-order interacting space (or some compressed version of it).\n\ncluster_ops\nclustered_ham\ntol: haven't yet set this up (NYI)\ncache: Should we cache the compressed H operators? Speeds up drastically, but uses lots of memory\n\nCompute compressed CEPA. Since there can be non-zero overlap with a multireference state, we need to generalize.\n\nHC = SCe\n\n|Haa + Hax| |1 | = |I   + Sax| |1 | E |Hxa + Hxx| |Cx|   |Sxa + I  | |Cx|\n\nHaa + HaxCx = (1 + SaxCx)E Hxa + HxxCx = SxaE + CxE\n\nThe idea for CEPA is to approximate E in the amplitude equation. CEPA(0): E = Eref\n\n(Hxx-Eref)Cx = SxaEref - Hxa\n\nAx=b\n\nAfter solving, the Energy can be obtained as: E = (Eref + HaxCx) / (1 + SaxCx)\n\n\n\n\n\n","category":"method"},{"location":"library/BST/#FermiCG.block_sparse_tucker-Union{Tuple{R}, Tuple{N}, Tuple{T}, Tuple{FermiCG.BSTstate{T,N,R},Any,Any}} where R where N where T","page":"BST","title":"FermiCG.block_sparse_tucker","text":"function block_sparse_tucker(input_vec::BSTstate{T,N,R}, cluster_ops, clustered_ham;\n    max_iter        = 20,\n    max_iter_pt     = 200, # max number of iterations for solving for PT1\n    nbody           = 4,\n    H0              = \"Hcmf\",\n    thresh_var      = 1e-4,\n    thresh_foi      = 1e-6,\n    thresh_pt       = 1e-5,\n    ci_conv         = 1e-5,\n    ci_max_iter     = 50,\n    ci_max_ss_vecs  = 12,\nresolve_ss      = false,\n    do_pt           = true,\n    tol_tucker      = 1e-6 ) where {T,N,R}\n\nArguments\n\ninput_vec::BSTstate: initial state\ncluster_ops: local cluster operators\nclustered_ham::ClusteredOperator: hamiltonian\nmax_iter = 20: max number of iterations\nmax_iter_pt = 200: max number of iterations to solve for the 1st order wavefunction\nnbody = 4: include up to nbody terms when forming the FOIS to search\nH0 = \"Hcmf\": zeroth-order hamiltonian for computing 1st order wavefunction [\"Hcmf\", \"H\"]\nnbody: max number of nbody terms in the Hamiltonian used for creating FOIS\nthresh_var: Compression threshold for the variational solution\nthresh_foi: Compression threshold for the FOIS\nthresh_pt: Compression threshold for the first-order wavefunction (if used)\nci_conv:     Convergence threshold for the CI (norm of residual)\nci_max_iter:    max iterations for CI problem\nci_max_ss_vecs: max number of subspace vectors for lanczos/davidson\nresolve_ss:  After compressing previous variational state, should we resolve in new subspace?\ndo_pt = true: Compute pt1 wavefunction for finding updated compression basis?\ntol_tucker: Convergence threshold for Tucker iterations (energy change)\nsolver: \n\nReturns\n\ne_var::Float64: the final variational energy\nv_var::BSTstate: the final variational state\n\nSee also: BSTstate, Tucker\n\n\n\n\n\n","category":"method"},{"location":"library/BST/#FermiCG.compute_expectation_value-Union{Tuple{R}, Tuple{N}, Tuple{T}, Tuple{FermiCG.BSTstate{T,N,R},Any,FermiCG.ClusteredOperator}} where R where N where T","page":"BST","title":"FermiCG.compute_expectation_value","text":"function compute_expectation_value(ci_vector::BSTstate{T,N,R}, cluster_ops, clustered_op::FermiCG.ClusteredOperator; nbody) where {T,N,R}\n\n\n\n\n\n","category":"method"},{"location":"library/BST/#HOSVD","page":"BST","title":"HOSVD","text":"","category":"section"},{"location":"library/BST/","page":"BST","title":"BST","text":"Modules = [FermiCG]\nPages   = [\"hosvd.jl\"]\nOrder   = [:type, :function]\nDepth\t= 2","category":"page"},{"location":"library/BST/#FermiCG.Tucker","page":"BST","title":"FermiCG.Tucker","text":"Simple Tucker (HOSVD) type\n\nData\n\ncore::Array{T, N}\nfactors::NTuple{N, Matrix{T}}\n\nTucker factors are stored as tall matrices the core tensor is actually a list of core tensors, to enable multistate calculations\n\n\n\n\n\n","category":"type"},{"location":"library/BST/#FermiCG.Tucker-Union{Tuple{FermiCG.Tucker{TT,NN,RR}}, Tuple{RR}, Tuple{NN}, Tuple{TT}} where RR where NN where TT","page":"BST","title":"FermiCG.Tucker","text":"function Tucker(t::Tucker{T,N,R}, n_roots::Integer) where {T,N,R}\n\nCreate a new Tucker with a different number of core tensors; R=n_roots. New core tensors added are initialized to zero.\n\n\n\n\n\n","category":"method"},{"location":"library/BST/#FermiCG.compress-Union{Tuple{FermiCG.Tucker{T,N,R}}, Tuple{R}, Tuple{N}, Tuple{T}} where R where N where T","page":"BST","title":"FermiCG.compress","text":"compress(t::Tucker{T,N}; thresh=1e-7, max_number=nothing) where {T,N}\n\nTry to compress further \n\n\n\n\n\n","category":"method"},{"location":"library/BST/#FermiCG.nonorth_add-Union{Tuple{Array{FermiCG.Tucker{T,N,R},1}}, Tuple{R}, Tuple{N}, Tuple{T}} where R where N where T<:Number","page":"BST","title":"FermiCG.nonorth_add","text":"add(tucks::Vector{Tucker{T,N}}; thresh=1e-10, max_number=nothing) where {T,N}\n\nAdd together multiple Tucker instances. Assumed non-orthogonal.\n\nArguments\n\ntucks::Vector{Tucker{T,N}}: Vector of Tucker objects\n\n\n\n\n\n","category":"method"},{"location":"library/BST/#FermiCG.nonorth_dot-Union{Tuple{R2}, Tuple{R1}, Tuple{N}, Tuple{T}, Tuple{FermiCG.Tucker{T,N,R1},FermiCG.Tucker{T,N,R2},Any,Any}} where R2 where R1 where N where T","page":"BST","title":"FermiCG.nonorth_dot","text":"function nonorth_dot(t1::Tucker{T,N,R}, t2::Tucker{T,N,R}) where {T,N,R}\n\nNote: This doesn't assume t1 and t2 have the same compression vectors \n\n\n\n\n\n","category":"method"},{"location":"library/BST/#FermiCG.nonorth_dot-Union{Tuple{R}, Tuple{N}, Tuple{T}, Tuple{FermiCG.Tucker{T,N,R},FermiCG.Tucker{T,N,R}}} where R where N where T","page":"BST","title":"FermiCG.nonorth_dot","text":"function nonorth_dot(t1::Tucker{T,N,R}, t2::Tucker{T,N,R}) where {T,N,R}\n\nNote: This doesn't assume t1 and t2 have the same compression vectors \n\n\n\n\n\n","category":"method"},{"location":"library/BST/#FermiCG.nonorth_overlap-Union{Tuple{R}, Tuple{N}, Tuple{T}, Tuple{FermiCG.Tucker{T,N,R},FermiCG.Tucker{T,N,R}}} where R where N where T","page":"BST","title":"FermiCG.nonorth_overlap","text":"function nonorth_overlap(t1::Tucker{T,N,R}, t2::Tucker{T,N,R}) where {T,N,R}\n\nNote: This doesn't assume t1 and t2 have the same compression vectors. Returns RxR overlap matrix \n\n\n\n\n\n","category":"method"},{"location":"library/BST/#FermiCG.orth_dot-Union{Tuple{R}, Tuple{N}, Tuple{T}, Tuple{FermiCG.Tucker{T,N,R},FermiCG.Tucker{T,N,R}}} where R where N where T","page":"BST","title":"FermiCG.orth_dot","text":"function orth_dot(t1::Tucker{T,N,R}, t2::Tucker{T,N,R}) where {T,N,R}\n\nNote: This assumes t1 and t2 have the same compression vectors \n\n\n\n\n\n","category":"method"},{"location":"library/BST/#FermiCG.transform_basis-Union{Tuple{N}, Tuple{T}, Tuple{Array{T,N},Dict{Int64,Array{T,2}}}} where N where T","page":"BST","title":"FermiCG.transform_basis","text":"\n\n\n\n","category":"method"},{"location":"library/BST/#FermiCG.transform_basis-Union{Tuple{N}, Tuple{T}, Tuple{Array{T,N},Tuple{Vararg{Array{T,2},N}}}} where N where T<:Number","page":"BST","title":"FermiCG.transform_basis","text":"\n\n\n\n","category":"method"},{"location":"library/BST/#FermiCG.transform_basis-Union{Tuple{R}, Tuple{N}, Tuple{T}, Tuple{Tuple{Vararg{Array{T,N},R}},Any}} where R where N where T<:Number","page":"BST","title":"FermiCG.transform_basis","text":"\n\n\n\n","category":"method"},{"location":"library/BST/#FermiCG.tucker_decompose-Union{Tuple{Tuple{Vararg{Array{T,N},R}}}, Tuple{R}, Tuple{N}, Tuple{T}} where R where N where T","page":"BST","title":"FermiCG.tucker_decompose","text":"function tucker_decompose(A::Array{T,N}; thresh=1e-7, max_number=nothing, verbose=1, type=\"magnitude\") where {T,N}\n\nTucker Decomposition of dense tensor:      A ~ X *(1) U1 *(2) U2 .... where cluster states are discarded based on the corresponding SVD #Arguments\n\nA: matrix to decompose\nthresh: threshold for discarding tucker factors\nmax_number: limit number of tucker factors to this value\ntype: type of trunctation. \"magnitude\" discards values smaller than this number.    \"sum\" discards values such that the sum of discarded values is smaller than thresh.\n\n\n\n\n\n","category":"method"},{"location":"library/BST/#FermiCG.tucker_recompose-Tuple{Any,Any}","page":"BST","title":"FermiCG.tucker_recompose","text":"tucker_recompose(core, factors)\n\nRecompose Tucker Decomposition \n\n\n\n\n\n","category":"method"},{"location":"library/CMFs/#CMF","page":"CMF","title":"CMF","text":"","category":"section"},{"location":"library/CMFs/#Background","page":"CMF","title":"Background","text":"","category":"section"},{"location":"library/CMFs/","page":"CMF","title":"CMF","text":"The Cluster Mean Field (CMF) approach used in this work was developed by Jimènez-Hoyos and Scuseria. ","category":"page"},{"location":"library/CMFs/#Algorithm","page":"CMF","title":"Algorithm","text":"","category":"section"},{"location":"library/CMFs/#Index","page":"CMF","title":"Index","text":"","category":"section"},{"location":"library/CMFs/","page":"CMF","title":"CMF","text":"Pages = [\"CMFs.md\"]","category":"page"},{"location":"library/CMFs/#Documentation","page":"CMF","title":"Documentation","text":"","category":"section"},{"location":"library/CMFs/","page":"CMF","title":"CMF","text":"Modules = [FermiCG]\nPages   = [\"CMFs.jl\"]\nOrder   = [:type, :function]\nDepth\t= 2","category":"page"},{"location":"library/CMFs/#FermiCG.cmf_ci-NTuple{5,Any}","page":"CMF","title":"FermiCG.cmf_ci","text":"cmf_ci(ints, clusters, fspace, in_rdm1a, in_rdm1b; \n            max_iter=10, dconv=1e-6, econv=1e-10, verbose=1,sequential=false)\n\nOptimize the 1RDM for CMF-CI\n\n#Arguments\n\nints::InCoreInts: integrals for full system\nclusters::Vector{Cluster}: vector of cluster objects\nfspace::Vector{Vector{Integer}}: vector of particle number occupations for each cluster specifying the sectors of fock space \nin_rdm1a: initial guess for 1particle density matrix for alpha electrons\nin_rdm1b: initial guess for 1particle density matrix for beta electrons\ndconv: Convergence threshold for change in density \neconv: Convergence threshold for change in energy \nsequential: Use the density matrix of the previous cluster in a cMF iteration to form effective integrals. Improves comvergence, may depend on cluster orderings   \nverbose: Printing level \n\n\n\n\n\n","category":"method"},{"location":"library/CMFs/#FermiCG.cmf_ci-Tuple{Molecule,Array{T,2} where T,Array{Cluster,1},Array{T,1} where T,Any,Any}","page":"CMF","title":"FermiCG.cmf_ci","text":"cmf_ci(mol::Molecule, C::Matrix, clusters::Vector{Cluster}, fspace::Vector, dguess; \n        max_iter=10, dconv=1e-6, econv=1e-10, verbose=1)\n\nOptimize the 1RDM for CMF-CI, without requiring an InCoreInts object \n\nArguments\n\nmol::Molecule: a FermiCG.Molecule type\nC: MO coefficients for full system (spin restricted)\nclusters::Vector{Cluster}: vector of Cluster objects\nfspace::Vector{Vector{Integer}}: vector of particle number occupations for each cluster specifying the sectors of fock space \ndguess: initial guess for 1particle density matrix (spin summed) \ndconv: Convergence threshold for change in density \neconv: Convergence threshold for change in energy \nverbose: how much to print\n\n\n\n\n\n","category":"method"},{"location":"library/CMFs/#FermiCG.cmf_ci_iteration-Tuple{InCoreInts,Array{Cluster,1},Any,Any,Any}","page":"CMF","title":"FermiCG.cmf_ci_iteration","text":"cmf_ci_iteration(ints::InCoreInts, clusters::Vector{Cluster}, rdm1a, rdm1b, fspace; verbose=1)\n\nPerform single CMF-CI iteration, returning new energy, and density\n\n\n\n\n\n","category":"method"},{"location":"library/CMFs/#FermiCG.cmf_ci_iteration-Tuple{Molecule,Any,Any,Any,Any,Any}","page":"CMF","title":"FermiCG.cmf_ci_iteration","text":"cmf_ci_iteration(mol::Molecule, C, rdm1a, rdm1b, clusters, fspace; \n                 verbose=1)\n\nPerform single CMF-CI iteration, returning new energy, and density. This method forms the eri's on the fly to avoid global N^4 storage\n\nArguments\n\nmol::Molecule: a FermiCG.Molecule type\nC: MO coefficients for full system (spin restricted)\nrdm1a: 1particle density matrix (alpha) \nrdm1b: 1particle density matrix (beta) \nclusters::Vector{Cluster}: vector of Cluster objects\nfspace::Vector{Vector{Int}}: vector of particle number occupations for each cluster specifying the sectors of fock space \nverbose: how much to print\nci_max_iter: How many FCI iterations do we allow for each cluster. Default=40\nci_conv_tol: How what is the convergence (gradient norm) for the FCI on each cluster. Default=1e-8 \n\nSee also: cmf_ci_iteration\n\n\n\n\n\n","category":"method"},{"location":"library/CMFs/#FermiCG.cmf_oo-Tuple{InCoreInts,Array{Cluster,1},Any,Any,Any}","page":"CMF","title":"FermiCG.cmf_oo","text":"cmf_oo(ints::InCoreInts, clusters::Vector{Cluster}, fspace, dguess_a, dguess_b; \n            max_iter_oo=100, max_iter_ci=100, gconv=1e-6, verbose=0, method=\"bfgs\", alpha=nothing,sequential=false)\n\nDo CMF with orbital optimization\n\n#Arguments\n\nints::InCoreInts: integrals for full system\nclusters::Vector{Cluster}: vector of cluster objects\nfspace::Vector{Vector{Integer}}: vector of particle number occupations for each cluster specifying the sectors of fock space \ndguess_a: initial guess for 1particle density matrix for alpha electrons\ndguess_b: initial guess for 1particle density matrix for beta electrons\nmax_iter_oo: Max iter for the orbital optimization iterations \nmax_iter_ci: Max iter for the cmf iteration for the cluster states \ngconv: Convergence threshold for change in gradient of energy \nsequential: If true use the density matrix of the previous cluster in a cMF iteration to form effective integrals. Improves comvergence, may depend on cluster orderings   \nverbose: Printing level \nmethod: optimization method\n\n\n\n\n\n","category":"method"},{"location":"library/CMFs/#FermiCG.cmf_oo-Tuple{Molecule,Array{T,2} where T,Array{Cluster,1},Any,Any}","page":"CMF","title":"FermiCG.cmf_oo","text":"cmf_oo(mol::Molecule, Cguess::Matrix, clusters::Vector{Cluster}, fspace, dguess; \n        max_iter_oo=100, max_iter_ci=100, gconv=1e-6, verbose=0, method=\"bfgs\")\n\nDo CMF with orbital optimization with on the fly integrals\n\n\n\n\n\n","category":"method"},{"location":"library/CMFs/#FermiCG.compute_cmf_energy-NTuple{4,Any}","page":"CMF","title":"FermiCG.compute_cmf_energy","text":"compute_cmf_energy(ints, rdm1s, rdm2s, clusters)\n\nCompute the energy of a cluster-wise product state (CMF), specified by a list of 1 and 2 particle rdms local to each cluster. This method uses the full system integrals.\n\nints::InCoreInts: integrals for full system\nrdm1s: dictionary (ci.idx => Array) of 1rdms from each cluster (spin summed)\nrdm2s: dictionary (ci.idx => Array) of 2rdms from each cluster (spin summed)\nclusters::Vector{Cluster}: vector of cluster objects\n\nreturn the total CMF energy\n\n\n\n\n\n","category":"method"},{"location":"library/CMFs/#FermiCG.compute_cmf_energy-Tuple{Molecule,Array{T,2} where T,Any,Any,Any}","page":"CMF","title":"FermiCG.compute_cmf_energy","text":"compute_cmf_energy(mol::Molecule, C::Matrix, rdm1s, rdm2s, clusters)\n\nCompute the energy of a cluster-wise product state (CMF), specified by a list of 1 and 2 particle rdms local to each cluster\n\n#Arguments\n\nmol::Molecule\nC::Matrix: MO coefficients\nrdm1s: dictionary (ci.idx => Array) of 1rdms from each cluster (spin summed)\nrdm2s: dictionary (ci.idx => Array) of 2rdms from each cluster (spin summed)\nclusters::Vector{Cluster}: vector of cluster objects\n\nreturn the total CMF energy\n\n\n\n\n\n","category":"method"},{"location":"library/CMFs/#FermiCG.form_1rdm_dressed_ints-Tuple{InCoreInts,Any,Any,Any}","page":"CMF","title":"FermiCG.form_1rdm_dressed_ints","text":"form_1rdm_dressed_ints(ints::InCoreInts, orb_list, rdm1a, rdm1b)\n\nObtain a subset of integrals which act on the orbitals in Cluster, embedding the 1rdm from the rest of the system\n\nReturns an InCoreInts type\n\n\n\n\n\n","category":"method"},{"location":"library/CMFs/#FermiCG.form_casci_ints-Tuple{InCoreInts,Cluster,Any,Any}","page":"CMF","title":"FermiCG.form_casci_ints","text":"form_casci_ints(ints::InCoreInts, ci::Cluster, rdm1a, rdm1b)\n\nObtain a subset of integrals which act on the orbitals in Cluster, embedding the 1rdm from the rest of the system\n\nReturns an InCoreInts type\n\n\n\n\n\n","category":"method"},{"location":"library/ClusteredTerms/","page":"ClusteredTerms","title":"ClusteredTerms","text":"Pages = [\"ClusteredTerms.md\"]","category":"page"},{"location":"library/ClusteredTerms/#ClusteredTerms","page":"ClusteredTerms","title":"ClusteredTerms","text":"","category":"section"},{"location":"library/ClusteredTerms/","page":"ClusteredTerms","title":"ClusteredTerms","text":"Modules = [FermiCG]\nPages   = [\"ClusteredTerms.jl\"]\nOrder   = [:type, :function]\nDepth\t= 2","category":"page"},{"location":"library/outline/#Library-Outline","page":"-","title":"Library Outline","text":"","category":"section"},{"location":"library/outline/","page":"-","title":"-","text":"Pages = [\"public.md\", \"internals.md\", \"function_index.md\"]","category":"page"},{"location":"library/FermiCG/","page":"FermiCG","title":"FermiCG","text":"Pages = [\"FermiCG.md\"]","category":"page"},{"location":"library/FermiCG/#FermiCG","page":"FermiCG","title":"FermiCG","text":"","category":"section"},{"location":"library/FermiCG/","page":"FermiCG","title":"FermiCG","text":"Modules = [FermiCG]\nPages   = [\"FermiCG.jl\"]\nOrder   = [:type, :function]\nDepth\t= 2","category":"page"},{"location":"library/PyscfFunctions/","page":"PyscfFunctions","title":"PyscfFunctions","text":"Pages = [\"PyscfFunctions.md\"]","category":"page"},{"location":"library/PyscfFunctions/#PySCF-Functions","page":"PyscfFunctions","title":"PySCF Functions","text":"","category":"section"},{"location":"library/PyscfFunctions/","page":"PyscfFunctions","title":"PyscfFunctions","text":"Modules = [FermiCG]\nPages   = [\"PyscfFunctions.jl\"]\nOrder   = [:type, :function]\nDepth\t= 2","category":"page"},{"location":"library/PyscfFunctions/#FermiCG.get_ovlp-Tuple{Any}","page":"PyscfFunctions","title":"FermiCG.get_ovlp","text":"get_ovlp(mf)\n\nGet overlap matrix from pyscf using mean-field object\n\n\n\n\n\n","category":"method"},{"location":"library/PyscfFunctions/#FermiCG.localize-Tuple{Array{Float64,2},String,Any}","page":"PyscfFunctions","title":"FermiCG.localize","text":"localize(C::Array{Float64,2},method::String, mf)\n\nLocalize the orbitals using method = method\n\n\n\n\n\n","category":"method"},{"location":"library/PyscfFunctions/#FermiCG.localize-Tuple{Array{Float64,2},String,Molecule}","page":"PyscfFunctions","title":"FermiCG.localize","text":"localize(C::Array{Float64,2}, method::String, mol::Molecule)\n\nLocalize the orbitals using method = method (pm, boys, lowdin)\n\n\n\n\n\n","category":"method"},{"location":"library/PyscfFunctions/#FermiCG.make_pyscf_mole-Tuple{Molecule}","page":"PyscfFunctions","title":"FermiCG.make_pyscf_mole","text":"make_pyscf_mole(molecule::Molecule)\n\nCreate a pyscf.gto.Mole() object\n\n\n\n\n\n","category":"method"},{"location":"library/PyscfFunctions/#FermiCG.pyscf_build_1e-Tuple{Molecule}","page":"PyscfFunctions","title":"FermiCG.pyscf_build_1e","text":"pyscf_build_1e(mol::Molecule)\n\nbuild 1 electron integrals in AO basis \n\nArguments\n\nmol::Molecule \n\nreturns a 2D matrix \n\n\n\n\n\n","category":"method"},{"location":"library/PyscfFunctions/#FermiCG.pyscf_build_eri-Tuple{Molecule,Array{T,2} where T,Array{T,2} where T,Array{T,2} where T,Array{T,2} where T}","page":"PyscfFunctions","title":"FermiCG.pyscf_build_eri","text":"pyscf_build_eri(mol::Molecule, c1::Matrix, c2::Matrix, c3::Matrix, c4::Matrix)\n\nbuild 2 electron integrals between different orbital spaces, (c1c2|c3c4) \n\nArguments\n\nmol::Molecule \nc1: active space orbital MO coeffs for index 1\nc2: active space orbital MO coeffs for index 2\nc3: active space orbital MO coeffs for index 3\nc4: active space orbital MO coeffs for index 4\n\nreturns a 4D tensor \n\n\n\n\n\n","category":"method"},{"location":"library/PyscfFunctions/#FermiCG.pyscf_build_ints-Tuple{Molecule,Any,Any}","page":"PyscfFunctions","title":"FermiCG.pyscf_build_ints","text":"pyscfbuildints(mol, cact, d1embed)\n\nbuild 1 and 2 electron integrals using a pyscf SCF object\n\nArguments\n\nmol: PySCF Molecule object\nc_act: active space orbital MO coeffs\nd1_embed: 1rdm density matrix for the frozen part in the AO basis (e.g, doccs or frozen clusters)\n\nreturns an InCoreInts type\n\n\n\n\n\n","category":"method"},{"location":"library/PyscfFunctions/#FermiCG.pyscf_build_ints-Tuple{Molecule,Any}","page":"PyscfFunctions","title":"FermiCG.pyscf_build_ints","text":"pyscfbuildints(mol, C)\n\nbuild 1 and 2 electron integrals using a pyscf SCF object\n\nArguments\n\nmol: PySCF Molecule object\nc: MO coeffs\n\nreturns an InCoreInts type\n\n\n\n\n\n","category":"method"},{"location":"library/PyscfFunctions/#FermiCG.pyscf_do_scf-Tuple{Molecule}","page":"PyscfFunctions","title":"FermiCG.pyscf_do_scf","text":"pyscf_do_scf(molecule::Molecule, conv_tol=1e-10)\n\nUse PySCF to compute Hartree-Fock for a given molecule and basis set and return a PYSCF mean field object\n\n\n\n\n\n","category":"method"},{"location":"library/PyscfFunctions/#FermiCG.pyscf_fci-Tuple{Any,Any,Any}","page":"PyscfFunctions","title":"FermiCG.pyscf_fci","text":"pyscf_fci(ham, na, nb; \n    max_cycle=40, conv_tol=1e-11, nroots=1, verbose=1, do_rdm1=true, do_rdm2=true)\n\nUse PySCF to compute Full CI\n\n\n\n\n\n","category":"method"},{"location":"library/PyscfFunctions/#FermiCG.pyscf_get_jk-Tuple{Molecule,Any}","page":"PyscfFunctions","title":"FermiCG.pyscf_get_jk","text":"pyscf_get_jk(mol, density)\n\nBuild exchange matrix in AO basis\n\nArguments\n\nmol: PySCF Molecule object\ndensity: 1rdm density matrix for \n\n\n\n\n\n","category":"method"},{"location":"library/PyscfFunctions/#FermiCG.pyscf_write_molden-Tuple{Any}","page":"PyscfFunctions","title":"FermiCG.pyscf_write_molden","text":"pyscf_write_molden(mf; filename=\"orbitals.molden\")\n\nArguments\n\nmf: PySCF mean field object\nfilename: Filename to write to\n\nWrite MO coeffs C to a molden file for visualizing\n\n\n\n\n\n","category":"method"},{"location":"library/PyscfFunctions/#FermiCG.pyscf_write_molden-Tuple{Molecule,Any}","page":"PyscfFunctions","title":"FermiCG.pyscf_write_molden","text":"pyscf_write_molden(molecule::Molecule, C; filename=\"orbitals.molden\")\n\nArguments\n\nmolecule::Molecule: Molecule object\nC: MO Coefficients\nfilename: Filename to write to\n\nWrite MO coeffs C to a molden file for visualizing\n\n\n\n\n\n","category":"method"},{"location":"library/function_index/#main-index","page":"-","title":"Index","text":"","category":"section"},{"location":"library/function_index/","page":"-","title":"-","text":"Pages = [\"public.md\", \"internals.md\", \"function_index.md\"]","category":"page"},{"location":"fci/#Simple-(and-slow)-FCI-Calculation-(FCI)","page":"Simple (and slow) FCI Calculation (FCI)","title":"Simple (and slow) FCI Calculation (FCI)","text":"","category":"section"},{"location":"fci/","page":"Simple (and slow) FCI Calculation (FCI)","title":"Simple (and slow) FCI Calculation (FCI)","text":"In this example, we cluster a sequence of H<sub>2</sub> molecules","category":"page"},{"location":"fci/#First-create-a-molecule","page":"Simple (and slow) FCI Calculation (FCI)","title":"First create a molecule","text":"","category":"section"},{"location":"fci/","page":"Simple (and slow) FCI Calculation (FCI)","title":"Simple (and slow) FCI Calculation (FCI)","text":"using FermiCG\n\natoms = []\npush!(atoms,Atom(1,\"H\",[0,0,0]))\npush!(atoms,Atom(2,\"H\",[0,0,1]))\npush!(atoms,Atom(3,\"H\",[0,0,2]))\npush!(atoms,Atom(4,\"H\",[0,0,3]))\npush!(atoms,Atom(5,\"H\",[0,0,4]))\npush!(atoms,Atom(6,\"H\",[0,0,5]))\nbasis = \"sto-3g\"","category":"page"},{"location":"fci/","page":"Simple (and slow) FCI Calculation (FCI)","title":"Simple (and slow) FCI Calculation (FCI)","text":"Now create a PySCF object for creating integrals, and run FCI with 3 alpha and 3 beta electrons","category":"page"},{"location":"fci/","page":"Simple (and slow) FCI Calculation (FCI)","title":"Simple (and slow) FCI Calculation (FCI)","text":"mol  = Molecule(0,1,atoms)\nmf   = FermiCG.pyscf_do_scf(mol,basis)\nints = FermiCG.pyscf_build_ints(mf.mol,mf.mo_coeff);\n\nna = 3\nnb = 3\ne_fci, d1_fci, d2_fci = FermiCG.pyscf_fci(ints,na,nb)\nC = mf.mo_coeff\nrdm_mf = C[:,1:2] * C[:,1:2]'","category":"page"},{"location":"fci/","page":"Simple (and slow) FCI Calculation (FCI)","title":"Simple (and slow) FCI Calculation (FCI)","text":"Create an FCIProblem object containing problem data","category":"page"},{"location":"fci/","page":"Simple (and slow) FCI Calculation (FCI)","title":"Simple (and slow) FCI Calculation (FCI)","text":"norbs = size(ints.h1)[1]\n\nproblem = StringCI.FCIProblem(norbs, 4, 4)","category":"page"},{"location":"fci/","page":"Simple (and slow) FCI Calculation (FCI)","title":"Simple (and slow) FCI Calculation (FCI)","text":"Now run the CI code. This seems to be about 10x slower than pyscf at the moment, and only uses lanczos instead of a preconditioned solver ","category":"page"},{"location":"fci/","page":"Simple (and slow) FCI Calculation (FCI)","title":"Simple (and slow) FCI Calculation (FCI)","text":"StringCI.run_fci(ints, problem)","category":"page"},{"location":"library/Internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"library/Internals/","page":"Internals","title":"Internals","text":"Pages = [\"Internals.md\"]","category":"page"},{"location":"library/Internals/#Clusters","page":"Internals","title":"Clusters","text":"","category":"section"},{"location":"library/Internals/","page":"Internals","title":"Internals","text":"Clusters are simply collections of orbitals.","category":"page"},{"location":"library/Internals/","page":"Internals","title":"Internals","text":"Modules = [FermiCG]\nPages   = [\"Clusters.jl\"]\nOrder   = [:type, :function]\nDepth\t= 2","category":"page"},{"location":"library/Internals/#Hamiltonians","page":"Internals","title":"Hamiltonians","text":"","category":"section"},{"location":"library/Internals/","page":"Internals","title":"Internals","text":"These are types/methods to handle the fermionic Hamiltonian","category":"page"},{"location":"library/Internals/","page":"Internals","title":"Internals","text":"Modules = [FermiCG]\nPages   = [\"Hamiltonians.jl\"]\nOrder   = [:type, :function]\nDepth\t= 2","category":"page"},{"location":"library/TPSCI/#TPSCI","page":"TPSCI","title":"TPSCI","text":"","category":"section"},{"location":"library/TPSCI/#Background","page":"TPSCI","title":"Background","text":"","category":"section"},{"location":"library/TPSCI/","page":"TPSCI","title":"TPSCI","text":"Tensor Product Selected CI (TPSCI) approximates FCI on large active spaces using a sparse basis of tensor products of many-body cluster states. The main idea is fold much of the electron correlation up into the basis vectors themselves, by diagonalizing local Hamiltonians (Hamiltonians acting on disjoint sets of orbitals, \"clusters\"),  and using the tensor product space of these cluster states as our basis.  For entangled clusters, the convergence of the global energy with the number of local cluster states is slow, making direct truncation of the cluster basis ineffective.  However, instead of seeking a simple trunctation based on local information,  we seek a sparse representation, such that only a small number of global states are needed to obtain an accurate approximation of the ground state. ","category":"page"},{"location":"library/TPSCI/#Algorithm","page":"TPSCI","title":"Algorithm","text":"","category":"section"},{"location":"library/TPSCI/","page":"TPSCI","title":"TPSCI","text":"The algorithm consists of the following steps:","category":"page"},{"location":"library/TPSCI/","page":"TPSCI","title":"TPSCI","text":"CMF: Optimize both orbitals and cluster ground states to obtain the variationally best single tensor product state wavefunction.\nCompute basis: Compute up to M excited states in each Fock sector desired (defaults to all) for each cluster.   These are excited states of the CMF Hamiltonian, which is an effective 1-cluster Hamiltonian containing the 1RDM contributions from all other clusters.\nForm operators: Compute matrix representations of all the 1, 2, and 3 creation/annihilation operator strings in the CMF cluster basis. E.g.:\nGamma_p^dagger qbarr^IJ = leftIright hatp^dagger hatqhatbarrleft Jright\nwhere I and J are cluster states on the same cluster, with well defined particle number and spin-projection. \nInitialize iterations: Set iteration counter to zero (n=0).  Initialize TPSCI state with CMF wavefunction, in the current mathcalP-space basis lbrace leftP_i^0rightrbrace, with the orthogonal complement defining the mathcalQ-space, lbrace leftQ_i^0rightrbrace.\nIterate Selected CI: \nDiagonalize hatH in the current mathcalP-space, lbrace leftP_i^nrightrbrace\nhatP^nhatHleftpsi^(0)_nright = E_nleftpsi^(0)_nright\nForm PT1 wavefunction by applying the Hamiltonian to the current variational state \nleftpsi^(1)_nright = hatRleftpsi^(0)_nright = sum_i c_i^(1)leftQ_i^nright\nwhere, hatR is the relevant resolvant. \nSelect from  leftpsi^(1)_nright the coefficients with magnitude larger than thresh_cipsi and add to mathcalP space:\nlbraceleftQ^n_irightrbrace xrightarrowc_i^(1)  epsilonlbraceleftP^n+1_jrightrbrace ","category":"page"},{"location":"library/TPSCI/#Tips-on-clustering","page":"TPSCI","title":"Tips on clustering","text":"","category":"section"},{"location":"library/TPSCI/#Performance-considerations","page":"TPSCI","title":"Performance considerations","text":"","category":"section"},{"location":"library/TPSCI/","page":"TPSCI","title":"TPSCI","text":"Robust integral screening\nthresh_asci \nHOSVD boot-strapping","category":"page"},{"location":"library/TPSCI/#Index","page":"TPSCI","title":"Index","text":"","category":"section"},{"location":"library/TPSCI/","page":"TPSCI","title":"TPSCI","text":"Pages = [\"TPSCI.md\"]","category":"page"},{"location":"library/TPSCI/#Documentation","page":"TPSCI","title":"Documentation","text":"","category":"section"},{"location":"library/TPSCI/","page":"TPSCI","title":"TPSCI","text":"Modules = [FermiCG]\nPages   = [\"tpsci_inner.jl\",\"tpsci_outer.jl\",\"tpsci_matvec_thread.jl\"]\nOrder   = [:type, :function]\nDepth\t= 2","category":"page"},{"location":"library/TPSCI/#FermiCG.contract_matrix_element-Union{Tuple{T}, Tuple{FermiCG.ClusteredTerm1B{T},Array{FermiCG.ClusterOps{T},1},FockConfig,ClusterConfig,FockConfig,ClusterConfig}} where T","page":"TPSCI","title":"FermiCG.contract_matrix_element","text":"contract_matrix_element(   term::ClusteredTerm1B, \n                                cluster_ops::Vector{ClusterOps{T}},\n                                fock_bra::FockConfig, bra::ClusterConfig, \n                                fock_ket::FockConfig, ket::ClusterConfig)\n\nContraction for local (1body) terms. No contraction is needed, just a lookup from the correct operator\n\n\n\n\n\n","category":"method"},{"location":"library/TPSCI/#FermiCG.contract_matrix_element-Union{Tuple{T}, Tuple{FermiCG.ClusteredTerm2B{T},Array{FermiCG.ClusterOps{T},1},FockConfig,ClusterConfig,FockConfig,ClusterConfig}} where T","page":"TPSCI","title":"FermiCG.contract_matrix_element","text":"contract_matrix_element(   term::ClusteredTerm2B, \n                                cluster_ops::Vector{ClusterOps{T}},\n                                fock_bra::FockConfig, bra::ClusterConfig, \n                                fock_ket::FockConfig, ket::ClusterConfig)\n\nForm TPSCI matrix element by contracting operators with integrals for 2body terms. \n\n\n\n\n\n","category":"method"},{"location":"library/TPSCI/#FermiCG.contract_matrix_element-Union{Tuple{T}, Tuple{FermiCG.ClusteredTerm3B{T},Array{FermiCG.ClusterOps{T},1},FockConfig,ClusterConfig,FockConfig,ClusterConfig}} where T","page":"TPSCI","title":"FermiCG.contract_matrix_element","text":"contract_matrix_element(   term::ClusteredTerm3B, \n                                cluster_ops::Vector{ClusterOps{T}},\n                                fock_bra::FockConfig, bra::ClusterConfig, \n                                fock_ket::FockConfig, ket::ClusterConfig)\n\nForm TPSCI matrix element by contracting operators with integrals for 3body terms. \n\n\n\n\n\n","category":"method"},{"location":"library/TPSCI/#FermiCG.contract_matrix_element-Union{Tuple{T}, Tuple{FermiCG.ClusteredTerm4B{T},Array{FermiCG.ClusterOps{T},1},FockConfig,ClusterConfig,FockConfig,ClusterConfig}} where T","page":"TPSCI","title":"FermiCG.contract_matrix_element","text":"contract_matrix_element(   term::ClusteredTerm4B, \n                                cluster_ops::Vector{ClusterOps{T}},\n                                fock_bra::FockConfig, bra::ClusterConfig, \n                                fock_ket::FockConfig, ket::ClusterConfig)\n\nForm TPSCI matrix element by contracting operators with integrals for 4body terms. \n\n\n\n\n\n","category":"method"},{"location":"library/TPSCI/#FermiCG.contract_matvec-Union{Tuple{N}, Tuple{R}, Tuple{T}, Tuple{FermiCG.ClusteredTerm1B,Array{FermiCG.ClusterOps,1},FockConfig{N},FockConfig{N},ClusterConfig{N},StaticArrays.MArray{Tuple{R},T,1,R}}} where N where R where T","page":"TPSCI","title":"FermiCG.contract_matvec","text":"contract_matvec(   term::ClusteredTerm1B, \n                                cluster_ops::Vector{ClusterOps},\n                                fock_bra::FockConfig{N}, \n                                fock_ket::FockConfig{N}, conf_ket::ClusterConfig{N}, coef_ket::MVector{R,T};\n                                thresh=1e-9) where {T,R,N}\n\n\n\n\n\n","category":"method"},{"location":"library/TPSCI/#FermiCG.contract_matvec-Union{Tuple{N}, Tuple{R}, Tuple{T}, Tuple{FermiCG.ClusteredTerm2B,Array{FermiCG.ClusterOps,1},FockConfig{N},FockConfig{N},ClusterConfig{N},StaticArrays.MArray{Tuple{R},T,1,R}}} where N where R where T","page":"TPSCI","title":"FermiCG.contract_matvec","text":"contract_matvec(   term::ClusteredTerm2B, \n                                cluster_ops::Vector{ClusterOps},\n                                fock_bra::FockConfig{N}, \n                                fock_ket::FockConfig{N}, conf_ket::ClusterConfig{N}, coef_ket::MVector{R,T};\n                                thresh=1e-9) where {T,R,N}\n\n\n\n\n\n","category":"method"},{"location":"library/TPSCI/#FermiCG.contract_matvec-Union{Tuple{N}, Tuple{R}, Tuple{T}, Tuple{FermiCG.ClusteredTerm3B,Array{FermiCG.ClusterOps,1},FockConfig{N},FockConfig{N},ClusterConfig{N},StaticArrays.MArray{Tuple{R},T,1,R}}} where N where R where T","page":"TPSCI","title":"FermiCG.contract_matvec","text":"contract_matvec(   term::ClusteredTerm3B, \n                                cluster_ops::Vector{ClusterOps},\n                                fock_bra::FockConfig{N}, \n                                fock_ket::FockConfig{N}, conf_ket::ClusterConfig{N}, coef_ket::MVector{R,T};\n                                thresh=1e-9, prescreen=true) where {T,R,N}\n\nThis version should only use M^2N^2 storage, and n^5 scaling n={MN}\n\n\n\n\n\n","category":"method"},{"location":"library/TPSCI/#FermiCG.contract_matvec-Union{Tuple{N}, Tuple{R}, Tuple{T}, Tuple{FermiCG.ClusteredTerm4B,Array{FermiCG.ClusterOps,1},FockConfig{N},FockConfig{N},ClusterConfig{N},StaticArrays.MArray{Tuple{R},T,1,R}}} where N where R where T","page":"TPSCI","title":"FermiCG.contract_matvec","text":"contract_matvec(   term::ClusteredTerm4B, \n                                cluster_ops::Vector{ClusterOps},\n                                fock_bra::FockConfig{N}, \n                                fock_ket::FockConfig{N}, conf_ket::ClusterConfig{N}, coef_ket::MVector{R,T};\n                                thresh=1e-9, prescreen=true) where {T,R,N}\n\nThis version should only use M^2N^2 storage, and n^5 scaling n={MN}\n\n\n\n\n\n","category":"method"},{"location":"library/TPSCI/#FermiCG.contract_matvec_M3-Union{Tuple{N}, Tuple{R}, Tuple{T}, Tuple{FermiCG.ClusteredTerm3B,Array{FermiCG.ClusterOps,1},FockConfig{N},FockConfig{N},ClusterConfig{N},StaticArrays.MArray{Tuple{R},T,1,R}}} where N where R where T","page":"TPSCI","title":"FermiCG.contract_matvec_M3","text":"contract_matvec_M3(   term::ClusteredTerm3B, \n                                cluster_ops::Vector{ClusterOps},\n                                fock_bra::FockConfig{N}, \n                                fock_ket::FockConfig{N}, conf_ket::ClusterConfig{N}, coef_ket::MVector{R,T};\n                                thresh=1e-9) where {T,R,N}\n\n\n\n\n\n","category":"method"},{"location":"library/TPSCI/#FermiCG.contract_matvec_M4-Union{Tuple{N}, Tuple{R}, Tuple{T}, Tuple{FermiCG.ClusteredTerm4B,Array{FermiCG.ClusterOps,1},FockConfig{N},FockConfig{N},ClusterConfig{N},StaticArrays.MArray{Tuple{R},T,1,R}}} where N where R where T","page":"TPSCI","title":"FermiCG.contract_matvec_M4","text":"contract_matvec_M4(   term::ClusteredTerm4B, \n                                cluster_ops::Vector{ClusterOps},\n                                fock_bra::FockConfig{N}, \n                                fock_ket::FockConfig{N}, conf_ket::ClusterConfig{N}, coef_ket::MVector{R,T};\n                                thresh=1e-9) where {T,R,N}\n\n\n\n\n\n","category":"method"},{"location":"library/TPSCI/#FermiCG.upper_bound-Tuple{Any,Any}","page":"TPSCI","title":"FermiCG.upper_bound","text":"upper_bound(g1, g2; c::Float64=1.0)\n\nReturn upper bound on the size of matrix elements resulting from matrix multiply \n\nV[I,J] =  g1[i,I] * g2[i,J] * c \n\nmax(|V|) <= sum_i max|g1[i,:]| * max|g2[i,:]| * |c|\n\n\n\n\n\n","category":"method"},{"location":"library/TPSCI/#FermiCG.upper_bound-Tuple{Array{Float64,2},Any,Any}","page":"TPSCI","title":"FermiCG.upper_bound","text":"upper_bound(v::Array{Float64,2}, g1, g2; c::Float64=1.0)\n\nReturn upper bound on the size of tensor elements resulting from the following contraction\n\nV[I,J] = v[i,j] * g1[i,I] * g2[j,J] \n\nmax(|V|) <= sum_ij |v[ij]| * |g1[i,:]|_8 * |g2[j,:]|_8 * |c|\n\n\n\n\n\n","category":"method"},{"location":"library/TPSCI/#FermiCG.upper_bound-Tuple{Array{Float64,3},Any,Any,Any}","page":"TPSCI","title":"FermiCG.upper_bound","text":"upper_bound(v::Array{Float64,3}, g1, g2, g3; c::Float64=1.0)\n\nReturn upper bound on the size of tensor elements resulting from the following contraction\n\nV[I,J,K] = v[i,j,k] * g1[i,I] * g2[j,J] * g3[k,K] \n\nmax(|V|) <= sum_ijk |v[ijk]| * |g1[i,:]|_8 * |g2[j,:]|_8 * |g3[k,:]|_8 * |c|\n\n\n\n\n\n","category":"method"},{"location":"library/TPSCI/#FermiCG.upper_bound-Tuple{Array{Float64,4},Any,Any,Any,Any}","page":"TPSCI","title":"FermiCG.upper_bound","text":"upper_bound(v::Array{Float64,4}, g1, g2, g3, g4; c::Float64=1.0)\n\nReturn upper bound on the size of tensor elements resulting from the following contraction\n\nV[I,J,K,L] = v[i,j,k,l] * g1[i,I] * g2[j,J] * g3[k,K] * g4[l,L]\n\nmax(|V|) <= sum_ijkl |v[ijkl]| * |g1[i,:]|_8 * |g2[j,:]|_8 * |g3[k,:]|_8 * |g4[l,:]|_8\n\n\n\n\n\n","category":"method"},{"location":"library/TPSCI/#FermiCG.upper_bound2-Tuple{Array{Float64,3},Any,Any,Any,Any}","page":"TPSCI","title":"FermiCG.upper_bound2","text":"upper_bound2(v::Array{Float64,3}, g1, g2, g3, thresh; c::Float64=1.0)\n\nGet upper bound on the possible values \n\nmax(H_IJ(K)|_K <= sum_r (sum_pq vpqrs max(g1[p,:]) * max(g2[q,:]) * |c| ) * |g3(r,K)|\n\n\n\n\n\n","category":"method"},{"location":"library/TPSCI/#FermiCG.upper_bound2-Tuple{Array{Float64,4},Any,Any,Any,Any,Any}","page":"TPSCI","title":"FermiCG.upper_bound2","text":"upper_bound2(v::Array{Float64,4}, g1, g2, g3, g4, thresh; c::Float64=1.0)\n\nGet upper bound on the possible values \n\nmax(H_IJK(L)|_L <= sum_s (sum_pqr vpqrs max(g1[p,:]) * max(g2[q,:]) * max(g3[r,:]) * |c| ) * |g4(s,L)|\n\n\n\n\n\n","category":"method"},{"location":"library/TPSCI/#FermiCG.build_brdm-Tuple{TPSCIstate,Any,Any}","page":"TPSCI","title":"FermiCG.build_brdm","text":"build_brdm(ci_vector::TPSCIstate, ci, dims)\n\nBuild block reduced density matrix for Cluster,  ci\n\nci_vector::TPSCIstate = input state\nci = Cluster type for whihch we want the BRDM\ndims = list of dimensions for each fock sector\n\n\n\n\n\n","category":"method"},{"location":"library/TPSCI/#FermiCG.build_full_H-Tuple{TPSCIstate,Any,FermiCG.ClusteredOperator}","page":"TPSCI","title":"FermiCG.build_full_H","text":"build_full_H(ci_vector::TPSCIstate, cluster_ops, clustered_ham::ClusteredOperator)\n\nBuild full TPSCI Hamiltonian matrix in space spanned by ci_vector. This works in serial for the full matrix\n\n\n\n\n\n","category":"method"},{"location":"library/TPSCI/#FermiCG.build_full_H_parallel-Union{Tuple{R}, Tuple{N}, Tuple{T}, Tuple{TPSCIstate{T,N,R},TPSCIstate{T,N,R},Any,FermiCG.ClusteredOperator}} where R where N where T","page":"TPSCI","title":"FermiCG.build_full_H_parallel","text":"build_full_H_parallel(ci_vector::TPSCIstate, cluster_ops, clustered_ham::ClusteredOperator)\n\nBuild full TPSCI Hamiltonian matrix in space spanned by ci_vector. This works in serial for the full matrix\n\n\n\n\n\n","category":"method"},{"location":"library/TPSCI/#FermiCG.compute_diagonal!-Union{Tuple{R}, Tuple{N}, Tuple{T}, Tuple{Any,TPSCIstate{T,N,R},Any,Any}} where R where N where T","page":"TPSCI","title":"FermiCG.compute_diagonal!","text":"compute_diagonal!(Hd, vector::TPSCIstate{T,N,R}, cluster_ops, clustered_ham) where {T,N,R}\n\nForm the diagonal of the hamiltonan, clustered_ham, in the basis defined by vector\n\n\n\n\n\n","category":"method"},{"location":"library/TPSCI/#FermiCG.compute_diagonal-Union{Tuple{R}, Tuple{N}, Tuple{T}, Tuple{TPSCIstate{T,N,R},Any,Any}} where R where N where T","page":"TPSCI","title":"FermiCG.compute_diagonal","text":"compute_diagonal(vector::TPSCIstate{T,N,R}, cluster_ops, clustered_ham) where {T,N,R}\n\nForm the diagonal of the hamiltonan, clustered_ham, in the basis defined by vector\n\n\n\n\n\n","category":"method"},{"location":"library/TPSCI/#FermiCG.compute_expectation_value-Union{Tuple{R}, Tuple{N}, Tuple{T}, Tuple{TPSCIstate{T,N,R},Any,FermiCG.ClusteredOperator}} where R where N where T","page":"TPSCI","title":"FermiCG.compute_expectation_value","text":"compute_expectation_value(ci_vector::TPSCIstate{T,N,R}, cluster_ops, clustered_ham::ClusteredOperator; nbody=4) where {T,N,R}\n\nCompute expectation value of a ClusteredOperator (clustered_ham) for state ci_vector\n\n\n\n\n\n","category":"method"},{"location":"library/TPSCI/#FermiCG.compute_expectation_value_parallel-Union{Tuple{R}, Tuple{N}, Tuple{T}, Tuple{TPSCIstate{T,N,R},Any,FermiCG.ClusteredOperator}} where R where N where T","page":"TPSCI","title":"FermiCG.compute_expectation_value_parallel","text":"function compute_expectation_value_parallel(ci_vector::TPSCIstate{T,N,R}, cluster_ops, clustered_ham::ClusteredOperator) where {T,N,R}\n\n\n\n\n\n","category":"method"},{"location":"library/TPSCI/#FermiCG.expand_each_fock_space!-Union{Tuple{R}, Tuple{N}, Tuple{T}, Tuple{TPSCIstate{T,N,R},Array{ClusterBasis,1}}} where R where N where T","page":"TPSCI","title":"FermiCG.expand_each_fock_space!","text":"expand_each_fock_space!(s::TPSCIstate{T,N,R}, bases::Vector{ClusterBasis}) where {T,N,R}\n\nFor each fock space sector defined, add all possible basis states\n\nbasis::Vector{ClusterBasis} \n\n\n\n\n\n","category":"method"},{"location":"library/TPSCI/#FermiCG.expand_to_full_space!-Tuple{FermiCG.AbstractState,Array{ClusterBasis,1},Any,Any}","page":"TPSCI","title":"FermiCG.expand_to_full_space!","text":"expand_to_full_space!(s::AbstractState, bases::Vector{ClusterBasis}, na, nb)\n\nDefine all possible fock space sectors and add all possible basis states\n\nbasis::Vector{ClusterBasis} \nna: Number of alpha electrons total\nnb: Number of alpha electrons total\n\n\n\n\n\n","category":"method"},{"location":"library/TPSCI/#FermiCG.hosvd-Union{Tuple{R}, Tuple{N}, Tuple{T}, Tuple{TPSCIstate{T,N,R},Any}} where R where N where T","page":"TPSCI","title":"FermiCG.hosvd","text":"hosvd(ci_vector::TPSCIstate{T,N,R}, cluster_ops; hshift=1e-8, truncate=-1) where {T,N,R}\n\nPeform HOSVD aka Tucker Decomposition of TPSCIstate\n\n\n\n\n\n","category":"method"},{"location":"library/TPSCI/#FermiCG.project_out!-Tuple{TPSCIstate,TPSCIstate}","page":"TPSCI","title":"FermiCG.project_out!","text":"project_out!(v::TPSCIstate, w::TPSCIstate)\n\nProject w out of v      |v'> = |v> - |w><w|v>\n\n\n\n\n\n","category":"method"},{"location":"library/TPSCI/#FermiCG.tps_ci_davidson-Union{Tuple{R}, Tuple{N}, Tuple{T}, Tuple{TPSCIstate{T,N,R},Any,FermiCG.ClusteredOperator}} where R where N where T","page":"TPSCI","title":"FermiCG.tps_ci_davidson","text":"tps_ci_davidson(ci_vector::TPSCIstate{T,N,R}, cluster_ops, clustered_ham::ClusteredOperator) where {T,N,R}\n\nSolve for eigenvectors/values in the basis defined by ci_vector. Use iterative davidson solver.\n\n\n\n\n\n","category":"method"},{"location":"library/TPSCI/#FermiCG.tps_ci_direct-Union{Tuple{R}, Tuple{N}, Tuple{T}, Tuple{TPSCIstate{T,N,R},Any,FermiCG.ClusteredOperator}} where R where N where T","page":"TPSCI","title":"FermiCG.tps_ci_direct","text":"function tps_ci_direct( ci_vector::TPSCIstate{T,N,R}, cluster_ops, clustered_ham::ClusteredOperator;\n                    H_old    = nothing,\n                    v_old    = nothing,\n                    verbose   = 0) where {T,N,R}\n\nSolve for eigenvectors/values in the basis defined by ci_vector. Use direct diagonalization.\n\nIf updating existing matrix, pass in Hold/vold to avoid rebuilding that block\n\nArguments\n\nsolver: Which solver to use. Options = [\"davidson\", \"krylovkit\"]\n\n\n\n\n\n","category":"method"},{"location":"library/TPSCI/#FermiCG.tps_ci_matvec-Union{Tuple{R}, Tuple{N}, Tuple{T}, Tuple{TPSCIstate{T,N,R},Any,FermiCG.ClusteredOperator}} where R where N where T","page":"TPSCI","title":"FermiCG.tps_ci_matvec","text":"tps_ci_matvec(ci_vector::TPSCIstate{T,N,R}, cluster_ops, clustered_ham::ClusteredOperator) where {T,N,R}\n\nCompute the action of clustered_ham on ci_vector.\n\n\n\n\n\n","category":"method"},{"location":"library/TPSCI/#FermiCG.tpsci_ci-Union{Tuple{R}, Tuple{N}, Tuple{T}, Tuple{TPSCIstate{T,N,R},Any,FermiCG.ClusteredOperator}} where R where N where T","page":"TPSCI","title":"FermiCG.tpsci_ci","text":"tpsci_ci(ci_vector::TPSCIstate{T,N,R}, cluster_ops, clustered_ham::ClusteredOperator;\n        thresh_cipsi = 1e-2,\n        thresh_foi   = 1e-6,\n        thresh_asci  = 1e-2,\n        thresh_var   = nothing, \n        max_iter     = 10,\n        conv_thresh  = 1e-4,\n        nbody        = 4,\n        incremental  = true,\n        ci_conv      = 1e-5,\n        ci_max_iter  = 50,\n        ci_max_ss_vecs = 12,\n        davidson     = false,\n        max_mem_ci   = 20.0, \n        threaded     = true) where {T,N,R}\n\nRun TPSCI\n\nthresh_cipsi: threshold for which configurations to include in the variational space. Add if |c^{(1)}| > thresh_cipsi\nthresh_foi  : threshold for which terms to keep in the H|0> vector used to form the first order wavefunction\nthresh_asci : threshold for determining from which variational configurations  c^(0)_i > thresh_asci \nthresh_var  : threshold for clipping the result of the variational wavefunction. Not really needed default set to nothing \nmax_iter    : maximum selected CI iterations\nconv_thresh : stop selected CI iterations when energy change is smaller than conv_thresh\nnbody       : only consider up to nbody terms when searching for new configurations\nincremental : for the sigma vector incrementally between iterations\nci_conv     : convergence threshold for the inner CI step (only needed when davidson is used)\nci_max_iter : max iterations for inner CI step (only needed when davidson is used) \nci_max_ss_vecs: max subspace size for inner CI step (only needed when davidson is used) \ndavidson    : use davidson? changes to true after needing more than maxmemci\nmax_mem_ci  : maximum memory (Gb) allowed for storing full H. If more is needed, do Davidson. \nthreaded    : Use multithreading? \n\n\n\n\n\n","category":"method"},{"location":"library/TPSCI/#FermiCG.contract_matvec_thread-Union{Tuple{N}, Tuple{R}, Tuple{T}, Tuple{FermiCG.ClusteredTerm1B{T},Array{FermiCG.ClusterOps{T},1},FockConfig{N},FockConfig{N},ClusterConfig{N},StaticArrays.MArray{Tuple{R},T,1,R},Any,Array{Array{T,1},1},Array{Array{Int16,1},1},Array{StaticArrays.MArray{Tuple{N},Int16,1,N},1}}} where N where R where T","page":"TPSCI","title":"FermiCG.contract_matvec_thread","text":"contract_matvec_thread(   term::ClusteredTerm1B, \n                                cluster_ops::Vector{ClusterOps},\n                                fock_bra::FockConfig{N}, \n                                fock_ket::FockConfig{N}, conf_ket::ClusterConfig{N}, coef_ket::MVector{R,T},\n                                sig, \n                                scr_f::Vector{Vector{T}},  \n                                scr_i::Vector{Vector{Int16}},  \n                                scr_m::Vector{MVector{N,Int16}};  \n                                thresh=1e-9) where {T,R,N}\n\n\n\n\n\n","category":"method"},{"location":"library/TPSCI/#FermiCG.contract_matvec_thread-Union{Tuple{N}, Tuple{R}, Tuple{T}, Tuple{FermiCG.ClusteredTerm2B{T},Array{FermiCG.ClusterOps{T},1},FockConfig{N},FockConfig{N},ClusterConfig{N},StaticArrays.MArray{Tuple{R},T,1,R},Any,Array{Array{T,1},1},Array{Array{Int16,1},1},Array{StaticArrays.MArray{Tuple{N},Int16,1,N},1}}} where N where R where T","page":"TPSCI","title":"FermiCG.contract_matvec_thread","text":"contract_matvec_thread(   term::ClusteredTerm2B, \n                                cluster_ops::Vector{ClusterOps},\n                                fock_bra::FockConfig{N}, \n                                fock_ket::FockConfig{N}, conf_ket::ClusterConfig{N}, coef_ket::MVector{R,T},\n                                sig, \n                                scr_f::Vector{Vector{T}},  \n                                scr_i::Vector{Vector{Int16}},  \n                                scr_m::Vector{MVector{N,Int16}};  \n                                thresh=1e-9) where {T,R,N}\n\n\n\n\n\n","category":"method"},{"location":"library/TPSCI/#FermiCG.contract_matvec_thread-Union{Tuple{N}, Tuple{R}, Tuple{T}, Tuple{FermiCG.ClusteredTerm3B{T},Array{FermiCG.ClusterOps{T},1},FockConfig{N},FockConfig{N},ClusterConfig{N},StaticArrays.MArray{Tuple{R},T,1,R},Any,Array{Array{T,1},1},Array{Array{Int16,1},1},Array{StaticArrays.MArray{Tuple{N},Int16,1,N},1}}} where N where R where T","page":"TPSCI","title":"FermiCG.contract_matvec_thread","text":"contract_matvec_thread(   term::ClusteredTerm3B, \n                                cluster_ops::Vector{ClusterOps},\n                                fock_bra::FockConfig{N}, \n                                fock_ket::FockConfig{N}, conf_ket::ClusterConfig{N}, coef_ket::MVector{R,T},\n                                sig, \n                                scr_f::Vector{Vector{T}},  \n                                scr_i::Vector{Vector{Int16}},  \n                                scr_m::Vector{MVector{N,Int16}};  \n                                thresh=1e-9, prescreen=true) where {T,R,N}\n\nThis version should only use M^2N^2 storage, and n^4 scaling n={MN}\n\n\n\n\n\n","category":"method"},{"location":"library/TPSCI/#FermiCG.contract_matvec_thread-Union{Tuple{N}, Tuple{R}, Tuple{T}, Tuple{FermiCG.ClusteredTerm4B{T},Array{FermiCG.ClusterOps{T},1},FockConfig{N},FockConfig{N},ClusterConfig{N},StaticArrays.MArray{Tuple{R},T,1,R},Any,Array{Array{T,1},1},Array{Array{Int16,1},1},Array{StaticArrays.MArray{Tuple{N},Int16,1,N},1}}} where N where R where T","page":"TPSCI","title":"FermiCG.contract_matvec_thread","text":"contract_matvec_thread(   term::ClusteredTerm4B, \n                                cluster_ops::Vector{ClusterOps},\n                                fock_bra::FockConfig{N}, \n                                fock_ket::FockConfig{N}, conf_ket::ClusterConfig{N}, coef_ket::MVector{R,T},\n                                sig, \n                                scr_f::Vector{Vector{T}},  \n                                scr_i::Vector{Vector{Int16}},  \n                                scr_m::Vector{MVector{N,Int16}};  \n                                thresh=1e-9, prescreen=true) where {T,R,N}\n\nThis version should only use M^2N^2 storage, and n^5 scaling n={MN}\n\n\n\n\n\n","category":"method"},{"location":"library/TPSCI/#FermiCG.open_matvec_thread-Union{Tuple{R}, Tuple{N}, Tuple{T}, Tuple{TPSCIstate{T,N,R},Any,Any}} where R where N where T","page":"TPSCI","title":"FermiCG.open_matvec_thread","text":"open_matvec_thread(ci_vector::TPSCIstate{T,N,R}, cluster_ops, clustered_ham; thresh=1e-9, nbody=4) where {T,N,R}\n\nCompute the action of the Hamiltonian on a tpsci state vector. Open here, means that we access the full FOIS  (restricted only by thresh), instead of the action of H on v within a subspace of configurations.  This is essentially used for computing a PT correction outside of the subspace, or used for searching in TPSCI.\n\nThis parallellizes over FockConfigs in the output state, so it's not the most fine-grained, but it avoids data races in  filling the final vector\n\n\n\n\n\n","category":"method"},{"location":"library/TPSCI/#FermiCG.upper_bound2_thread-Union{Tuple{T}, Tuple{Array{T,3},Any,Any,Any,Array{Array{T,1},1},Array{Array{Int16,1},1},Any}} where T","page":"TPSCI","title":"FermiCG.upper_bound2_thread","text":"upper_bound2_thread(v::Array{T,4}, g1, g2, g3, \n    scr_f::Vector{Vector{T}}, scr_i::Vector{Vector{Int16}}, thresh; \n    c::T=1.0)\n\nmax(H_IJ(K)|_K <= sum_s (sum_pqr vpqrs max(g1[p,:]) * max(g2[q,:]) * |c| ) * |g3(r,K)|\n\n\n\n\n\n","category":"method"},{"location":"library/TPSCI/#FermiCG.upper_bound2_thread-Union{Tuple{T}, Tuple{Array{T,4},Any,Any,Any,Any,Array{Array{T,1},1},Array{Array{Int16,1},1},Any}} where T","page":"TPSCI","title":"FermiCG.upper_bound2_thread","text":"upper_bound2_thread(v::Array{T,4}, g1, g2, g3, g4, \n    scr_f::Vector{Vector{T}}, scr_i::Vector{Vector{Int16}}, thresh; \n    c::T=1.0)\n\nmax(H_IJK(L)|_L <= sum_s (sum_pqr vpqrs max(g1[p,:]) * max(g2[q,:]) * max(g3[r,:]) * |c| ) * |g4(s,L)|\n\n\n\n\n\n","category":"method"},{"location":"library/TPSCI/#FermiCG.upper_bound_thread-Union{Tuple{T}, Tuple{AbstractArray{T,3},Any,Any,Any,Any,Any,Any}} where T","page":"TPSCI","title":"FermiCG.upper_bound_thread","text":"upper_bound_thread(v::AbstractArray{T,3}, g1, g2, g3, scr1, scr2, scr3; c::T=1.0)\n\nReturn upper bound on the size of tensor elements resulting from the following contraction\n\nV[I,J,K] = v[i,j,k] * g1[i,I] * g2[j,J] * g3[k,K] \n\nmax(|V|) <= sum_ijk |v[ijk]| * |g1[i,:]|_8 * |g2[j,:]|_8 * |g3[k,:]|_8\n\n\n\n\n\n","category":"method"},{"location":"library/TPSCI/#FermiCG.upper_bound_thread-Union{Tuple{T}, Tuple{Any,Any}} where T","page":"TPSCI","title":"FermiCG.upper_bound_thread","text":"upper_bound_thread(g1, g2; c::T=1.0)\n\nReturn upper bound on the size of matrix elements resulting from matrix multiply \n\nV[I,J] =  g1[i,I] * g2[i,J] * c \n\nmax(|V|) <= sum_i max|g1[i,:]| * max|g2[i,:]| * |c|\n\n\n\n\n\n","category":"method"},{"location":"library/TPSCI/#FermiCG.upper_bound_thread-Union{Tuple{T}, Tuple{Array{T,4},Any,Any,Any,Any,Any,Any,Any,Any}} where T","page":"TPSCI","title":"FermiCG.upper_bound_thread","text":"upper_bound_thread(v::Array{T,4}, g1, g2, g3, g4, scr1, scr2, scr3, scr4; c::T=1.0)\n\nReturn upper bound on the size of tensor elements resulting from the following contraction\n\nV[I,J,K,L] = v[i,j,k,l] * g1[i,I] * g2[j,J] * g3[k,K] * g4[l,L]\n\nmax(|V|) <= sum_ijkl |v[ijkl]| * |g1[i,:]|_8 * |g2[j,:]|_8 * |g3[k,:]|_8 * |g4[l,:]|_8\n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/","page":"StringCI","title":"StringCI","text":"Pages = [\"StringCI.md\"]","category":"page"},{"location":"library/StringCI/#StringCI","page":"StringCI","title":"StringCI","text":"","category":"section"},{"location":"library/StringCI/","page":"StringCI","title":"StringCI","text":"Modules = [StringCI]\nPages   = [\"StringCI/StringCI.jl\", \"StringCI/DeterminantStrings.jl\", \"StringCI/FCI.jl\", \"StringCI/Helpers.jl\", \"StringCI/TDMs.jl\"]\nOrder   = [:module, :type, :function]\nDepth\t= 2","category":"page"},{"location":"library/StringCI/#FermiCG.StringCI","page":"StringCI","title":"FermiCG.StringCI","text":"Simple string-based CI code\n\n\n\n\n\n","category":"module"},{"location":"library/StringCI/#Base.copy!-Tuple{FermiCG.StringCI.DeterminantString,FermiCG.StringCI.DeterminantString}","page":"StringCI","title":"Base.copy!","text":"Base.copy!(c1::DeterminantString,c2::DeterminantString)\n\ncopy c2 into c1\n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.apply_annihilation!-Tuple{FermiCG.StringCI.DeterminantString,Int64}","page":"StringCI","title":"FermiCG.StringCI.apply_annihilation!","text":"apply_annihilation!(c::DeterminantString, orb_index::Int)\n\nApply an annihilation operator to c corresponding to orbital orb_index \n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.apply_creation!-Tuple{FermiCG.StringCI.DeterminantString,Int64}","page":"StringCI","title":"FermiCG.StringCI.apply_creation!","text":"apply_creation!(c::DeterminantString, orb_index::Int)\n\nApply a creation operator to c corresponding to orbital orb_index \n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.calc_linear_index!-Tuple{FermiCG.StringCI.DeterminantString,Array{Int64,2}}","page":"StringCI","title":"FermiCG.StringCI.calc_linear_index!","text":"calc_linear_index!(c::DeterminantString, binomcoeff::Array{Int,2})\n\nCalculate the linear index, passing in binomial coefficient matrix makes it much faster\n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.calc_linear_index!-Tuple{FermiCG.StringCI.DeterminantString}","page":"StringCI","title":"FermiCG.StringCI.calc_linear_index!","text":"calc_linear_index!(c::DeterminantString)\n\nCalculate the linear index\n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.calc_linear_index-Tuple{FermiCG.StringCI.DeterminantString}","page":"StringCI","title":"FermiCG.StringCI.calc_linear_index","text":"calc_linear_index(c::DeterminantString)\n\nReturn linear index for lexically ordered __config DeterminantString\n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.fill_ca_lookup-Tuple{FermiCG.StringCI.DeterminantString}","page":"StringCI","title":"FermiCG.StringCI.fill_ca_lookup","text":"fill_ca_lookup(c::DeterminantString)\n\nCreate an index table relating each DeterminantString with all ia substitutions i.e., calookup[Ka][c(p) + a(p)*np] = La\n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.fill_ca_lookup2-Tuple{FermiCG.StringCI.DeterminantString}","page":"StringCI","title":"FermiCG.StringCI.fill_ca_lookup2","text":"fill_ca_lookup2(c::DeterminantString)\n\nCreate an index table relating each DeterminantString with all ia substitutions i.e., ca_lookup[Ka,p,q] = sign*La\n\n<L|p'q|K> = sign\n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.fill_ca_lookup3-Tuple{FermiCG.StringCI.DeterminantString}","page":"StringCI","title":"FermiCG.StringCI.fill_ca_lookup3","text":"fill_ca_lookup3(c::DeterminantString)\n\nCreate an index table relating each DeterminantString with all ia substitutions i.e., ca_lookup[Ka,p,q] = (sign,La)\n\n<L|p'q|K> = sign\n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.get_unoccupied!-Tuple{Array{Int64,1},FermiCG.StringCI.DeterminantString}","page":"StringCI","title":"FermiCG.StringCI.get_unoccupied!","text":"get_unoccupied(c::DeterminantString)\n\nget list of orbitals that are unoccupied\n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.get_unoccupied-Tuple{FermiCG.StringCI.DeterminantString}","page":"StringCI","title":"FermiCG.StringCI.get_unoccupied","text":"get_unoccupied(c::DeterminantString)\n\nget list of orbitals that are unoccupied\n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.reset!-Tuple{FermiCG.StringCI.DeterminantString}","page":"StringCI","title":"FermiCG.StringCI.reset!","text":"reset!(c::DeterminantString)\n\nReset the DeterminantString to the first config\n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.build_H_matrix-Tuple{Any,FermiCG.StringCI.FCIProblem}","page":"StringCI","title":"FermiCG.StringCI.build_H_matrix","text":"build_H_matrix(ints, P::FCIProblem)\n\nBuild the Hamiltonian defined by ints in the Slater Determinant Basis  in the sector of Fock space specified by P\n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.build_S2_matrix-Tuple{FermiCG.StringCI.FCIProblem}","page":"StringCI","title":"FermiCG.StringCI.build_S2_matrix","text":"build_s2(prb::FCIProblem)\n\nprb: FCIProblem just defines the current CI problem (i.e., fock sector)\n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.compute_1rdm-Union{Tuple{T}, Tuple{FermiCG.StringCI.FCIProblem,Array{T,1},Array{T,1}}} where T","page":"StringCI","title":"FermiCG.StringCI.compute_1rdm","text":"\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.compute_ab_terms-Tuple{Any,Any,FermiCG.StringCI.FCIProblem,Any,Any}","page":"StringCI","title":"FermiCG.StringCI.compute_ab_terms","text":"compute_ab_terms(v, H, P::FCIProblem, ket_a_lookup, ket_b_lookup)\n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.compute_ab_terms-Tuple{Any,Any,FermiCG.StringCI.FCIProblem}","page":"StringCI","title":"FermiCG.StringCI.compute_ab_terms","text":"compute_ab_terms(v, H, P::FCIProblem)\n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.compute_ab_terms2-Tuple{Any,Any,FermiCG.StringCI.FCIProblem,Any,Any}","page":"StringCI","title":"FermiCG.StringCI.compute_ab_terms2","text":"compute_ab_terms2(v, H, P::FCIProblem, \n                      ket_a_lookup, ket_b_lookup)\n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.compute_ab_terms_full!-Tuple{Any,FermiCG.StringCI.FCIProblem,Any}","page":"StringCI","title":"FermiCG.StringCI.compute_ab_terms_full!","text":"compute_ab_terms_full!(H, P::FCIProblem, Hmat)\n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.compute_ab_terms_full-Tuple{Any,FermiCG.StringCI.FCIProblem}","page":"StringCI","title":"FermiCG.StringCI.compute_ab_terms_full","text":"compute_ab_terms_full(H, P::FCIProblem)\n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.compute_fock_diagonal-Tuple{FermiCG.StringCI.FCIProblem,Array{T,1} where T,Real}","page":"StringCI","title":"FermiCG.StringCI.compute_fock_diagonal","text":"compute_fock_diagonal!(H, P::FCIProblem, e_mf::Float64)\n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.compute_rdm1_rdm2-Union{Tuple{T}, Tuple{FermiCG.StringCI.FCIProblem,Array{T,1},Array{T,1}}} where T","page":"StringCI","title":"FermiCG.StringCI.compute_rdm1_rdm2","text":"\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.compute_ss_terms2-Tuple{Any,Any,FermiCG.StringCI.FCIProblem,Any,Any}","page":"StringCI","title":"FermiCG.StringCI.compute_ss_terms2","text":"compute_aa_terms2(v, H, P::FCIProblem, \n                      ket_a_lookup)\n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.do_fci-Tuple{FermiCG.StringCI.FCIProblem,Any,Any}","page":"StringCI","title":"FermiCG.StringCI.do_fci","text":"function do_fci(problem::FCIProblem, ints, nr; v0=Nothing, tol=1e-12)\n\nUse Arpack.eigs to diagonalize the problem\n\nproblem: FCIProblem to solve\nints: InCoreIntegrals\nnr: number of roots \nv0: Initial vector\ntol: convergence tolerance\n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.get_map-Tuple{Any,FermiCG.StringCI.FCIProblem,Any,Any}","page":"StringCI","title":"FermiCG.StringCI.get_map","text":"get_map(ham, prb::FCIProblem, HdiagA, HdiagB)\n\nAssumes you've already computed the spin diagonal components\n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.get_map-Tuple{Any,FermiCG.StringCI.FCIProblem}","page":"StringCI","title":"FermiCG.StringCI.get_map","text":"get_map(ham, prb::FCIProblem)\n\nGet LinearMap with takes a vector and returns action of H on that vector\n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.precompute_spin_diag_terms-Tuple{Any,FermiCG.StringCI.FCIProblem,Any}","page":"StringCI","title":"FermiCG.StringCI.precompute_spin_diag_terms","text":"precompute_spin_diag_terms(H, P::FCIProblem, e)\n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.run_fci-Tuple{Any,FermiCG.StringCI.FCIProblem}","page":"StringCI","title":"FermiCG.StringCI.run_fci","text":"run_fci(ints, prb::FCIProblem)\n\ninput: ints is a struct containing 0, 2, and 4 dimensional tensors\n\nh0: energy shift\nh1: 1 electron integrals\nh2: 2 electron integrals (chemists notation)\nprb: FCIProblem just defines the current CI problem (i.e., fock sector)\n\nints is simply an InCoreInts object from FermiCG\n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.svd_state-Tuple{Any,FermiCG.StringCI.FCIProblem,Any,Any,Any}","page":"StringCI","title":"FermiCG.StringCI.svd_state","text":"svd_state(prb::FCIProblem)\n\nDo an SVD of the FCI vector partitioned into clusters with (norbs1 | norbs2) where the orbitals are assumed to be ordered for cluster 1| cluster 2 haveing norbs1 and  norbs2, respectively.\n\nprb: FCIProblem just defines the current CI problem (i.e., fock sector)\nnorbs1:number of orbitals in left cluster\nnorbs2:number of orbitals in right cluster\nsvd_thresh: the threshold below which the states will be discarded\n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.calc_nchk-Tuple{Integer,Integer}","page":"StringCI","title":"FermiCG.StringCI.calc_nchk","text":"calc_nchk(n::Integer,k::Integer)\n\nCalculates binomial coefficient: n choose k\n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.get_nchk-Tuple{Any,Any}","page":"StringCI","title":"FermiCG.StringCI.get_nchk","text":"get_nchk(n::Integer,k::Integer)\n\nLooks up binomial coefficient from a precomputed table: n choose k\n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.compute_AA-Tuple{Integer,Any,Any,Any,Any,Array{T,2} where T,Array{T,2} where T,Any}","page":"StringCI","title":"FermiCG.StringCI.compute_AA","text":"compute_AA(no::Integer, bra_na, bra_nb, ket_na, ket_nb, bra_v::Matrix, ket_v::Matrix, spin_case)\n\nCompute represntation of 2creation operators between states bra_v and ket_v\n\nArguments\n\nno: number of orbitals\nbra_na: number of alpha electrons in bra\nbra_nb: number of beta electrons in bra\nket_na: number of alpha electrons in ket\nket_nb: number of beta electrons in ket\nbra_v: basis vectors in bra\nket_v: basis vectors ket\nspin_case: either (alpha|beta)\n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.compute_AAa-Tuple{Integer,Any,Any,Any,Any,Array{T,2} where T,Array{T,2} where T,Any}","page":"StringCI","title":"FermiCG.StringCI.compute_AAa","text":"compute_AAa(no::Integer, bra_na, bra_nb, ket_na, ket_nb, bra_v::Matrix, ket_v::Matrix, spin_case)\n\nCompute represntation of 2creation operators between states bra_v and ket_v\n\nArguments\n\nno: number of orbitals\nbra_na: number of alpha electrons in bra\nbra_nb: number of beta electrons in bra\nket_na: number of alpha electrons in ket\nket_nb: number of beta electrons in ket\nbra_v: basis vectors in bra\nket_v: basis vectors ket\nspin_case: either (alpha|beta)\n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.compute_AB-Tuple{Integer,Any,Any,Any,Any,Array{T,2} where T,Array{T,2} where T}","page":"StringCI","title":"FermiCG.StringCI.compute_AB","text":"compute_AB(no::Integer, bra_na, bra_nb, ket_na, ket_nb, bra_v::Matrix, ket_v::Matrix)\n\nCompute representation of p'q' operators between states bra_v and ket_v, where p is alpha and q is beta.\n\nArguments\n\nno: number of orbitals\nbra_na: number of alpha electrons in bra\nbra_nb: number of beta electrons in bra\nket_na: number of alpha electrons in ket\nket_nb: number of beta electrons in ket\nbra_v: basis vectors in bra\nket_v: basis vectors ket\n\nG(pqst) = v(IJs) <IJ|p'q'|KL> v(KLt) \n        = v(IJs) <J|<I|p'q'|K>|L> v(KLt)\n        = v(IJs) <J|<I|p'|K>q'|L> v(KLt) (-1)^N(K)\n        = v(IJs) <I|p'|K> <J|q'|L> v(KLt) (-1)^N(K)\n    \n        this can be vectorized if needed. for now:\n        loop over p,q\n            loop over K,L\n                sign = -1^N(K)\n                find indices of I,J\n                G(pq,st) += v(IJ,s) v(KL,t) * sign \n            end\n        end\n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.compute_ABa-Tuple{Integer,Any,Any,Any,Any,Array{T,2} where T,Array{T,2} where T}","page":"StringCI","title":"FermiCG.StringCI.compute_ABa","text":"compute_ABa(no::Integer, bra_na, bra_nb, ket_na, ket_nb, bra_v::Matrix, ket_v::Matrix, spin_case)\n\nCompute represntation of 2creation operators between states bra_v and ket_v\n\nArguments\n\nno: number of orbitals\nbra_na: number of alpha electrons in bra\nbra_nb: number of beta electrons in bra\nket_na: number of alpha electrons in ket\nket_nb: number of beta electrons in ket\nbra_v: basis vectors in bra\nket_v: basis vectors ket\nspin_case: either (alpha|beta) giving ABa or BAb\n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.compute_ABb-Tuple{Integer,Any,Any,Any,Any,Array{T,2} where T,Array{T,2} where T}","page":"StringCI","title":"FermiCG.StringCI.compute_ABb","text":"compute_ABb(no::Integer, bra_na, bra_nb, ket_na, ket_nb, bra_v::Matrix, ket_v::Matrix, spin_case)\n\nCompute represntation of 2creation operators between states bra_v and ket_v\n\nArguments\n\nno: number of orbitals\nbra_na: number of alpha electrons in bra\nbra_nb: number of beta electrons in bra\nket_na: number of alpha electrons in ket\nket_nb: number of beta electrons in ket\nbra_v: basis vectors in bra\nket_v: basis vectors ket\nspin_case: either (alpha|beta) giving ABa or BAb\n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.compute_Aa-Tuple{Integer,Any,Any,Any,Any,Array{T,2} where T,Array{T,2} where T,Any}","page":"StringCI","title":"FermiCG.StringCI.compute_Aa","text":"compute_Aa(no::Integer, bra_na, bra_nb, ket_na, ket_nb, bra_v::Matrix, ket_v::Matrix, spin_case)\n\nCompute representation of a'a operators between states bra_v and ket_v\n\nArguments\n\nno: number of orbitals\nbra_na: number of alpha electrons in bra\nbra_nb: number of beta electrons in bra\nket_na: number of alpha electrons in ket\nket_nb: number of beta electrons in ket\nbra_v: basis vectors in bra\nket_v: basis vectors ket\nspin_case: either (alpha|beta)\n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.compute_Ab-Tuple{Integer,Any,Any,Any,Any,Array{T,2} where T,Array{T,2} where T}","page":"StringCI","title":"FermiCG.StringCI.compute_Ab","text":"compute_Ab(no::Integer, bra_na, bra_nb, ket_na, ket_nb, bra_v::Matrix, ket_v::Matrix)\n\nCompute representation of p'q operators between states bra_v and ket_v, where p is alpha and q is beta.\n\nArguments\n\nno: number of orbitals\nbra_na: number of alpha electrons in bra\nbra_nb: number of beta electrons in bra\nket_na: number of alpha electrons in ket\nket_nb: number of beta electrons in ket\nbra_v: basis vectors in bra\nket_v: basis vectors ket\n\nG(pqst) = v(IJs) <IJ|p'q|KL> v(KLt) \n        = v(IJs) <J|<I|p'q|K>|L> v(KLt)\n        = v(IJs) <J|<I|p'|K>q|L> v(KLt) (-1)^N(K)\n        = v(IJs) <I|p'|K> <J|q|L> v(KLt) (-1)^N(K)\n    \n        this can be vectorized if needed. for now:\n        loop over p,q\n            loop over K,L\n                sign = -1^N(K)\n                find indices of I,J\n                G(pq,st) += v(IJ,s) v(KL,t) * sign \n            end\n        end\n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.compute_annihilation-Tuple{Integer,Any,Any,Any,Any,Array{T,2} where T,Array{T,2} where T,Any}","page":"StringCI","title":"FermiCG.StringCI.compute_annihilation","text":"compute_annihilation(no::Integer, bra_na, bra_nb, ket_na, ket_nb, bra_v::Matrix, ket_v::Matrix, spin_case)\n\nCompute an creation operator between states bra_v and ket_v\n\nArguments\n\nno: number of orbitals\nbra_na: number of alpha electrons in bra\nbra_nb: number of beta electrons in bra\nket_na: number of alpha electrons in ket\nket_nb: number of beta electrons in ket\nbra_v: basis vectors in bra\nket_v: basis vectors ket\nspin_case: either (alpha|beta)\n\n\n\n\n\n","category":"method"},{"location":"library/Utils/","page":"Utils","title":"Utils","text":"Pages = [\"Utils.md\"]","category":"page"},{"location":"library/Utils/#Utils","page":"Utils","title":"Utils","text":"","category":"section"},{"location":"library/Utils/","page":"Utils","title":"Utils","text":"Modules = [FermiCG]\nPages   = [\"Utils.jl\"]\nOrder   = [:type, :function]\nDepth\t= 2","category":"page"},{"location":"library/Utils/#FermiCG.bubble_sort-Tuple{Any}","page":"Utils","title":"FermiCG.bubble_sort","text":"function bubble_sort(inp)\n\nSort inp (stable)\n\n\n\n\n\n","category":"method"},{"location":"library/Utils/#FermiCG.get_nchk-Tuple{Any,Any}","page":"Utils","title":"FermiCG.get_nchk","text":"replace this with table lookup\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = FermiCG","category":"page"},{"location":"#FermiCG","page":"Home","title":"FermiCG","text":"","category":"section"},{"location":"library/public/#Public-Documentation","page":"Public Documentation","title":"Public Documentation","text":"","category":"section"},{"location":"library/public/","page":"Public Documentation","title":"Public Documentation","text":"Documentation for FermiCG.jl's public interface.","category":"page"},{"location":"library/public/","page":"Public Documentation","title":"Public Documentation","text":"See the Internals section of the manual for internal package docs covering all submodules.","category":"page"},{"location":"library/public/#FermiCG","page":"Public Documentation","title":"FermiCG","text":"","category":"section"},{"location":"library/public/","page":"Public Documentation","title":"Public Documentation","text":"Modules = [FermiCG]\nPages   = [\"FermiCG.jl\"]","category":"page"},{"location":"library/public/#FermiCG.FermiCG","page":"Public Documentation","title":"FermiCG.FermiCG","text":"General electronic course-graining platform\n\n\n\n\n\n","category":"module"}]
}
